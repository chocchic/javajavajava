# Mobile을 위한 Server 구축  
## 1. 개발 환경
* 데이터 베이스 : MySQL  
* 프로그래밍 언어 : Java  
* 프레임워크 : Spring Boot  
* IDE : STS  
* 버전 관리 : git hub  

## 2. 데이터 베이스 작업  
* 데이터베이스에 접속해서 이번 프로젝트에 사용할 데이터베이스를 생성  
create database choc;

## 3. Spring Boot Project 생성  
* build : gradle  
* 의존성 : spring dev tools, lombok, spring data jpa, mysql, spring web, thymeleaf  

## 4. 기본 설정  
### 1) application.properties에 작성  
```ini
# 서버 실행 포트 정보
server.port = 80

# 데이터베이스 접속 정보
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/choc?useUnicode=yes&characterEncoding=UTF-8&serverTimezon=UTC
spring.datasource.username=root
spring.datasource.password=1234

# 데이터베이스 사용 옵션 정보
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
spring.jpa.properties.hibernate.show_sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.ddl-auto=update
logging.level.org.hibernate.type.descriptor.sql=trace

#Live Reload
spring.devtools.livereload.enabled=true
```  

### 2) 외부 라이브러리의 의존성을 설정 - BCrypt(복호화가 되지 않은 암호화를 위한 라이브러리 - spring security를 사용하는 경우에는 불필요)
* build.gradle 파일의 dependecies파일에 작성  
// https://mvnrepository.com/artifact/org.mindrot/jbcrypt
implementation group: 'org.mindrot', name: 'jbcrypt', version: '0.4'

* 프로젝트 rebuild  

### 3) 데이터베이스 관련 기본 작업
* main 함수를 가진 클래스에 데이터베이스의 변경내용을 감시할 수 있도록 어노테이션을 설정  
@EnableJpaAuditing
```java
// 자바에서는 @가 붙은 단어를 Annotaion이라고 하고, Python에서는 Decorator라고 합니다.
// 자주 사용하는 코드를 하나의 클래스로 만든 후 이 클래스의 수행 코드를 예약어 형태로 만든 것입니다.
// 이런 코드를 Annotation을 이용해서 만들 수도 있고, AOP를 이용해서 설정하는 것도 가능합니다.
@EnableJpaAuditing
@SpringBootApplication
public class MobileServerApplication {

	public static void main(String[] args) {
		SpringApplication.run(MobileServerApplication.class, args);
	}

}
```  

* Entity들에서 자주 사용하는 속성(생성 날짜, 수정 날짜)들을 위한 Entity를 생성 : model.BaseEntity  
```java
// 테이블로 생성하지 말고 매핑 정보만 사용하겠다라는 의미
@MappedSuperclass
// Entity의 변경사항이 발생했을 때 작업을 수행
@EntityListeners(value= {AuditingEntityListener.class})
// Lombok 라이브러리에서 속성의 getter 메서드를 만들어주는 어노테이션
@Getter
public class BaseEntity {
	// 생성날짜를 이용
	@CreatedDate
	// 테이블에 만들어 질 떄는 regdate라는 컬럼으로 생성되고 수정은 할 수 없음
	@Column(name="regdate", updatable=false)
	private LocalDateTime regDate;

	// 마지막 수정 날짜를 이용
	@LastModifiedDate
	// 테이블에 만들어질 때는 moddate라는 컬럼으로 생성
	@Column(name="moddate")
	private LocalDateTime modDate;
}
```  

## 5. Entity 작업  
* 2개의 테이블을 생성  
하나의 테이블은 회원 정보이고 다른 하나의 테이블은 아이템 정보  
회원은 여러 개의 아이템을 등록할 수 있고 하나의 아이템은 하나의 회원만 등록이 가능  

* Entity를 만들고 application.properties파일에 spring.jpa.properties.hibernate.ddl-auto=update 옵션을 설정하면 테이블이 없으면 테이블이 자동으로 만들어지지만 실제 업무에서는 이 방식을 사용하지 않는데, 컬럼의 순서가 임의로 생성되고, 제약족건의 이름도 임의로 생성됩니다. 애플리케이션 프로그램이 DDL이나 DCL작업을 수행하는 것을 권장하지 않기 째문입니다.  

### 1) 데이터베이스에 접속해서 테이블을 생성하는 구문을 수행  
* sql 실행
```sql
create table tbl_member(
    email varchar(255) not null,
    password varchar(255) not null,
    name varchar(255),
    imageurl varchar(255),
    regdate datetime(6),
    moddate datetime(6),
    lastlogindate datetime(6),
    primary key(email)
)engine=InnoDB DEFAULT CHARSET=utf8;

create table item(
	itemid INTEGER primary key auto_increment,
	itemname varchar(100),
	price Integer,
	description varchar(200),
	pictureurl varchar(255)
    member_email varchar(255)
)engine=InnoDB DEFAULT CHARSET=utf8;
```  

### 2) tbl_member테이블과 연결할 Entity 생성model/Member.java 작성
```java
// 데이터벱이스의 테이블과 연결된 Entity로 설정
@Entity
// 연결할 테이블 이름 설정
@Table(name="tbl_member")
// Builder패턴으로 인스턴스를 생성하도록 해주는 어노테이션
@Builder
// 모든 속성을 매개변수로 하는 생성자를 생성
@AllArgsConstructor
// 매개변수가 없는 DefaultConstructor 생성
@NoArgsConstructor
@Getter
// 모든 속성의 toString을 호출한 결과를가지고 toString을 생성
@ToString
public class Member extends BaseEntity{
	@Id
	private String email;
	private String password;
	private String name;
	private String imageurl;
	private LocalDateTime lastlogindate;
}
```  

### 3) Item테이블과 연결할 Entity 생성 - model/Item.java  
```java
package com.choc.model;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.ManyToOne;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;

@Entity
@Builder
@AllArgsConstructor
@NoArgsConstructor
@Data
@ToString(exclude="member") // member.toString은 제외
public class Item {
	@Id
	// 기본키 값을 auto_increment나 sequence를 이용해서 자동 생성
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long itemid;
	@Column(length=100, nullable = false)
	private String itemname;
	@Column
	private Integer price;
	@Column(length = 200)
	private String description;
	@Column(length = 255)
	private String pictureurl;
	
	// 사용을 할 때 데이터를 가져오겠다는 옵션
	@ManyToOne(fetch=FetchType.LAZY)
	private Member member;
}
```  

## 6. Repository 작업  
### +)  Jpa에서 데이터베이스를 사용하는 방법  
#### 1. JpaRepository가 제공하는 기본 메서드를 사용하는 방법  
* Entity를 이용한 데이터 삽입, 데이터 수정(Id를 기준으로 수정), 데이터 삭제(Id를 기준으로 삭제)  
* id를 이용한 삭제 제공  
* 테이블의 전체 데이터를 조회, Pageable을 이용한 조회, 기본키를 이용한 조회  
#### 2. 메서드 이름을 이용하는 방법  
* 기능 + Entity이름(생략가능) + By + 컬럼이름으로 메서드를 생성  
* 조회와 삭제 가능
* 연산자(크다, 작다, 작거나 같다, 크거나 같다, 사이, like 등) 사용 가능  
* name을 이용한 데이터 조회 : findByName(String name)
* name을 이용한 삭제 : deleteByName(String name)  
#### 3. JPQL을 이용하는 방법 - join이 필요할 때 주로 이용  
@Query("쿼리")  
매서드이름(@Param("파라미터이름") 자료형 매개변수 이름 ... )  
#### 4. QueryDsl을 이용해서 JPQL을 동적으로 생성하는 방법  
* 값을 변경하는 쿼리는 정적으로 생성이 가능  
* 테이블 이름이나 컬럼이름을 변경해야 하는 경우는 **QueryDsl**을 이용해야 합니다.  
* 입력받은 값을 이용해서 title에서 조회 
	~> title = 입력받은 값, 이런 경우는 JPQL로 처리가 가능  
* 값을 입력받아서 어떤 경우에는 title에서 조회하고 다른 경우에는 content에서 조회해야 하는 경우  
	~> 이런 경우에는 JPQL을 동적으로 생성해야 합니다. 이 경우 "QueryDsl" 사용  

### 1) Member Entity작업을 위한 Repository 인터페이스 생성 - persistence.MemberRepository  
```java
// JpaRepository를 상속 받을 때는 Entity이름과 Id로 설정한 속성의 자료형이 필요
public interface MemberRepository extends JpaRepository<Member, String> {
	// 회원가입
	// 로그인
	// 회원 정보 가져오기
	// 회원 정보 수정
	// 회원 탈퇴
}
```  

### 2) test디렉터리에 Repository를 테스트할 수 있는 클래스를 만들고 테스트 - Repositorytest.java  
```java
package com.choc;

import java.util.Optional;

import org.junit.jupiter.api.Test;
import org.mindrot.jbcrypt.BCrypt;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import com.choc.model.Member;
import com.choc.persistence.MemberRepository;

@SpringBootTest
public class RepositoryTest {
	@Autowired
	private MemberRepository m;
	
	// Member에 데이터 삽입
	//@Test
	public void testRegisterMember() {
		/*
		Member member = Member.builder().email("dntksemfdj473@gmail.com")
				.password("159753").name("촉촉한초코칩").imageurl("chocochip.png").build();
		m.save(member);
		*/
		
		// BCrypt 사용해보기
		/*
		String password = BCrypt.hashpw("159753", BCrypt.gensalt()); 
		// 같은 데이터를 가지고 암호화해도 매번 다른 값이 나옴
		System.out.println(password);
		System.out.println(BCrypt.checkpw("159753", password)); // 평문이 같으면 true
		*/
		// password에 String 형태로 hash된 값이 들어간 것이 확인됨
		String password = BCrypt.hashpw("159753", BCrypt.gensalt());
		Member member = Member.builder().email("dntksemfdj473@gmail.com")
				.password(password).name("촉촉한초코칩").imageurl("chocochip.png").build();
		m.save(member);
	}
	
	// 회원 정보 가져오기 - 수정이나 로그인에서 사용  
	//@Test
	public void testGetMember() {
		Optional<Member> optional = m.findById("dntksemfdj473@gmail.com");
		if(optional.isPresent()) {
			Member member = optional.get();
			System.out.println(member); // 로그인은 데이터를 가져와서 비교하면 됨!
		}else {
			System.out.println("존재하지 않는 데이터입니다.");
		}
	}
	
	// 데이터 수정
	//@Test
	public void testUpdateMember() {
		String password = BCrypt.hashpw("111111", BCrypt.gensalt());
		Member member = Member.builder().email("dntksemfdj473@gmail.com")
				.password(password).name("칙촉").imageurl("user.png").build();
		
		m.save(member);
	}
	
	// 데이터 삭제
	@Test
	public void testDeleteMember() {
		// 2가지 방법 존재
		Member member = Member.builder().email("dntksemfdj473@gmail.com").build();
		m.delete(member);
		

		//m.deleteById("dntksemfdj473@gmail.com");
	}

	//이름으로 데이터 조회
	//@Test
	public void testFindName() {
		String name="칙촉";
		List<Member> list = m.findMemberByName(name);
		System.out.println(list);
		
		name = "촉촉한초코칩";
		list = m.findMemberByName(name);
		System.out.println(list);
		
	}
}
```  

### 3) Item테이블을 위한Repository 인터페이스 생성 - persistence.ItemRepository  
```java
public interface ItemRepository extends JpaRepository<Item, Long>{
	
	// Member를 이용해서 Member가 작성한 모든 Item을 조회하는 메서드
	List<Item> findItemByMember(Member member);
}
```

### 4) 이전에 만든 Test클래스에 코드를 추가하고 확인
```java
// ... 생략 ... 
	
	@SpringBootTest
	public class RepositoryTest {
	// ... 생략 ... 
	
	@Autowired
	private ItemRepository i;
	
	// Item 삽입을 테스트
	//@Test
	void testRegisterItem() {
		// 외래키를 생성
		Member member = Member.builder().email("dntksemfdj473@gmail.com").build();
		for(int j = 0; j< 100; j++) {
			Item item = Item.builder().itemname("사과").price(2500).description("비타민 C가 풍부합니다.")
				.pictureurl("apple.png").member(member).build();
			i.save(item);
		}
	}
	
	// 데이터 전체 보기 테스트
	//@Test
	public void getAll() {
		List<Item> list = i.findAll();
		System.out.println(list);
	}
	
	// 페이징과 정렬
	//@Test
	public void getPaging() {
		Sort sort = Sort.by("itemid").descending();
		Pageable pageable = PageRequest.of(0, 10);
		Page<Item> list = i.findAll(pageable);
		list.get().forEach(item-> {System.out.println(item);});
	}
	
	// 외래키를 이용한 조회
	//@Test
	public void getFindMember() {
		Member member = Member.builder().email("dntksemfdj473@gmail.com").build();
		List<Item> list = i.findItemByMember(member);
		System.out.println(list);
	}
	
	// 데이터 1개 가져오기
	//@Test
	public void getItem() {
		Optional<Item> item = i.findById(10L);
		if(item.isPresent()) {
			System.out.println(item.get());
		}else {
			System.out.println("데이터가 없습니다.");
		}
	}
	
	// 데이터 수정
	//@Test
	public void updateItem() {
		Member member = Member.builder().email("dntksemfdj473@gmail.com").build();
		Item item = Item.builder().itemid(10L).itemname("아오리사과").description("달고 아삭아삭해요~")
				.price(3450).pictureurl("greenapple.png").member(member).build();
		i.save(item);
	}
	
	// 데이터 삭제
	@Test
	public void deleteItem(){
		Item item = Item.builder().itemid(100L).build();
		i.delete(item);
	}
}
```  

## 7. Service 작업  
### 1) Member 요청을 처리할(파라미터를 받고 결과를 출력) DTO 클래스 생성 - dto.MemberDTO  
```java
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class MemberDTO {
	private String email;
	private String password;
	private String name;
	private String imageurl;
	// 전송된 파일의 내용을 저장할 속성
	private MultipartFile image;
	private LocalDateTime lastlogindate;
	private LocalDateTime regdate;
	private LocalDateTime moddate;
}
```  

### 2) Member 요청을 처리할 메서드의 원형을 가진 인터페이스 생성 - service.MemberService  
```java
public interface MemberService {
	// 데이터 삽입
	public String registerMember(MemberDTO dto);
	public MemberDTO loginMember(MemberDTO dto);
	public MemberDTO getMember(MemberDTO dto);
	public String updateMember(MemberDTO dto);
	public String deleteMember(MemberDTO dto);
	
	// DTO클래스의 객체를 Model클래스의 객체로 변환
	public default Member dtoToEntity(MemberDTO dto) {
		String password = BCrypt.hashpw(dto.getPassword(), BCrypt.gensalt());
		Member member = Member.builder().email(dto.getEmail()).name(dto.getName()).password(password)
				.imageurl(dto.getImageurl()).lastlogindate(dto.getLastlogindate()).build();
		
		return member;
	}
	
	// Model클래스의 객체를 DTO클래스의 객체로 변환
	public default MemberDTO entityToDto(Member member) {
		MemberDTO dto = MemberDTO.builder().email(member.getEmail()).name(member.getName()).imageurl(member.getImageurl())
				.regdate(member.getRegDate()).moddate(member.getModDate()).lastlogindate(member.getLastlogindate()).build();
		return dto;
	}
}
```

### 3) Memeber요청을 처리할 메서드를 구현한 MemberServiceImpl 클래스를 생성하고 작성  
```java
package com.choc.service;

import com.choc.dto.MemberDTO;
import com.choc.model.Member;
import com.choc.persistence.MemberRepository;

import lombok.RequiredArgsConstructor;

import java.util.List;
import java.util.Optional;

import org.mindrot.jbcrypt.BCrypt;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class MemberServiceImpl implements MemberService{
	private final MemberRepository memberRepository;
	
	@Override
	public String registerMember(MemberDTO dto) {
		Member member = dtoToEntity(dto);
		// 이메일 중복체크
		Optional<Member> optional = memberRepository.findById(dto.getEmail());
		if(optional.isPresent()) {
			return "존재하는 이메일";
		}
		// 이름 중복 체크
		List<Member> list = memberRepository.findMemberByName(dto.getName());
		if(list.size() > 0) {
			return "존재하는 이름";
		}
		memberRepository.save(member);
		return member.getEmail();
	}

	@Override
	public MemberDTO loginMember(MemberDTO dto) {
		// 이메일을 가지고 데이터를 찾아옴
		Optional<Member> optional = memberRepository.findById(dto.getEmail());
		
		if(optional.isPresent()) { // 존재하는 이메일
			// 비밀번호 확인
			Member member = optional.get();
			if(BCrypt.checkpw(dto.getPassword(), member.getPassword())) {
				return entityToDto(member);
			}//else {
			//	return null;
			//}
		}//else { // 존재하지 않는 이메일
		//	return null;
		//}
		return null;
	}

	@Override
	public MemberDTO getMember(MemberDTO dto) {
		// 이메일을 가지고 데이터를 찾아옴
		Optional<Member> optional = memberRepository.findById(dto.getEmail());
		
		if(optional.isPresent()) { // 존재하는 이메일
			// 비밀번호 확인
			Member member = optional.get();
			if(BCrypt.checkpw(dto.getPassword(), member.getPassword())) {
				return entityToDto(member);
			}//else {
			//	return null;
			//}
		}
		return null;
	}

	@Override
	public String updateMember(MemberDTO dto) {
		Member member =dtoToEntity(dto);
		memberRepository.save(member);
		return member.getEmail();
	}

	@Override
	public String deleteMember(MemberDTO dto) {
		Member member = dtoToEntity(dto);
		memberRepository.delete(member);
		return member.getEmail();
	}

}
```

### 4) Service 계층을 테스트하기 위한 클래스를 생성하고 작성  
```java
@SpringBootTest
public class ServiceTest {
	@Autowired
	private MemberService m;
	
	// 회원가입 테스트
	//@Test
	public void testRegisterMember() {
		// 처음 추가를 할때는 성공, email과 name이 중복된 데이터면 실패
		MemberDTO dto = MemberDTO.builder().email("youremail@site.com").password("yourpw")
				.name("yourname").imageurl("yourimg.png").build();
		
		String result = m.registerMember(dto);
		System.out.println(result);
	}
	
	// 회원 정보 가져오기
	//@Test
	public void testGetMember() {
		MemberDTO dto = MemberDTO.builder().email("youremail@site.com").build();
		MemberDTO result = m.getMember(dto);
		System.out.println(result);
	}
	
	// 로그인 테스트
	@Test
	public void testLoginMember() {
		MemberDTO dto = MemberDTO.builder().email("youremail@site.com").password("yourpw").build();
		MemberDTO result = m.loginMember(dto);
		System.out.println(result);
		
		// 오늘 날짜를 생성
		Date date = new Date();
		SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");
		String d = sdf.format(date);
		try {
			// true값 주면 같은 이름의 파일에 append
			FileOutputStream fos = new FileOutputStream("C:\\Users\\SAMSUNG\\Desktop\\java\\chocchic.github.io\\react_native\\MobileServer\\"+ d + ".txt", true);
			PrintWriter pw  = new PrintWriter(fos);
			pw.println("내용");
			pw.flush();
			pw.close();
		}catch(Exception e) {
			
		}
	}
	
	// 멤버 수정 테스트
	//@Test
	public void updateMember() {
		MemberDTO dto = MemberDTO.builder().email("youremail@site.com").name("NAME").password("pw1234")
				.imageurl("user.png").build();
		String result = m.updateMember(dto);
		System.out.println(result);
	}
	
	// 멤버 삭제 테스트
	@Test
	public void deleteMember() {
		MemberDTO dto = MemberDTO.builder().email("youremail@site.com").build();
		String result = m.deleteMember(dto);
		System.out.println(result);
	}
}
```  

### 5) ItemEntity를 Controller나 Service에서 사용하기 위한 ItemDTO클래스를 생성하고 작성  
```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ItemDTO {
	private Long itemid;
	private String itemname;
	private Integer price;
	private String description;
	// 업로드된 이미지 경로를 저장
	private String pictureurl;
	// 파일을 받아오기 위한 변수
	private MultipartFile image;
	// Entity를 만들 때는 Entity를 외래키로 추가하지만 화면 입출력할 때는 필요한 데이터만 선언  
	private String email;
}
```  

### 6) 페이지 단위 요청을 위한 DTO - dto/PageRequestDTO  
```java
@Data
@Builder
@AllArgsConstructor
public class PageRequestItemDTO {
	// 페이지 번호 - 1부터 시작
	private int page;
	// 한 페이지에 보여질 데이터 개수
	private int size;
	// 특정 항목으로 조회하고자 하는 경우
	//private String condition;
	//private String keyword;
	
	// 생성자
	public PageRequestItemDTO() {
		page = 1;
		size =10;
	}
	// 페이지 번호와 데이터 개수를 가지고 Pageable 객체를 생성해주는 메서드
	public Pageable getPageable(Sort sort) {
		// JPA에서는 페이지번호가 0부터 시작하기 때문에 page-1을 해주어야 뷰에서는 1부터 시작하고, DB에서는 0부터 페이징가능
		return PageRequest.of(page-1,size,sort);
	}
}
```  

### 7) 페이지단위로 출력을 하기 위한 DTO - dto/PageResponseItemDTO  
```java
@Data
public class PageResponseItemDTO {
	// Dto 리스트
	private List<Item> itemList;
	
	// 전체 페이지 개수
	private int totalPage;
	// 현재 페이지 번호
	private int page;
	
	// 페이지 번호 목록 크기
	private int size;
	// 출력할 페이지 번호 시작과 종료
	private int start, end;
	
	// 이전과 다음 여부
	private boolean prev,next;
	//페이지 번호 목록
	private List<Integer> pageList;
	
	// 페이지 번호 목록을 만들어주는 메서드
	public void makePageList(Pageable pageable) {
		page = pageable.getPageNumber()+1;
		size = pageable.getPageSize();
		
		int tempEnd = (int)(Math.ceil(page/10.0))*10;
		start = tempEnd - 9;
		prev = start > 1;
		end = totalPage > tempEnd ? tempEnd : totalPage;
		next = tempEnd < totalPage;
		pageList = IntStream.rangeClosed(start, end).boxed().collect(Collectors.toList());
	}
	
}
```  

### 8) Item 요청을 처리할 메서드의 원형을 가진 서비스 인터페이스를 생성 - service/ItemService
```java
public interface ItemService {
	// 아이템 등록
	public Long registerItem(ItemDTO dto);
	// 하나의 아이템 가져오기
	public ItemDTO getItem(ItemDTO dto);
	// 아이템 수정
	public Long updateItem(ItemDTO dto);
	// 아이템 삭제
	public Long deleteItem(ItemDTO dto);
	
	// 페이지 단위로 데이터가져오기
	public PageResponseItemDTO getList(PageRequestItemDTO dto);
	
	// DTO를 Entity로 변환해주는 메서드
	public default Item dtoToEntity(ItemDTO dto) {
		Item item = Item.builder().itemid(dto.getItemid()).itemname(dto.getItemname()).price(dto.getPrice())
				.description(dto.getDescription()).pictureurl(dto.getPictureurl())
				.member(Member.builder().email(dto.getEmail()).build()).build();
		return item;
	}
	
	// Entity를 DTO로 변환해주는 메서드
	public default ItemDTO entitytoDto(Item item) {
		ItemDTO dto = ItemDTO.builder().itemid(item.getItemid()).itemname(item.getItemname()).price(item.getPrice())
				.description(item.getDescription()).pictureurl(item.getPictureurl()).email(item.getMember().getEmail()).build();
		return dto;
	}
}
```  

### 9) Item에 대한 요청을 처리하는 메서드를 구현할 ServiceImpl클래스를 생성하고 메서드 구현  
```java
@Service
@RequiredArgsConstructor
public class ItemServiceImpl implements ItemService{
	private final ItemRepository itemRepository;
	
	@Override
	public Long registerItem(ItemDTO dto) {
		Item item = dtoToEntity(dto);
		itemRepository.save(item);
		return item.getItemid();
	}

	@Override
	public ItemDTO getItem(ItemDTO dto) {
		Long itemid = dto.getItemid();
		Optional<Item> op = itemRepository.findById(itemid);
		if(op.isPresent()) {
			return entitytoDto(op.get());
		}
		return null;
	}

	@Override
	public Long updateItem(ItemDTO dto) {
		Item item = dtoToEntity(dto);
		Long itemid = item.getItemid();
		itemRepository.save(item);
		return itemid;
	}

	@Override
	public Long deleteItem(ItemDTO dto) {
		Item item = dtoToEntity(dto);
		Long itemid = item.getItemid();
		itemRepository.deleteById(itemid);
		return itemid;
	}

	@Override
	public PageResponseItemDTO getList(PageRequestItemDTO dto) {
		Sort sort = Sort.by("itemid").descending();
		Pageable pageable = PageRequest.of(dto.getPage()-1, dto.getSize(), sort);
		Page<Item> page = itemRepository.findAll(pageable);
		PageResponseItemDTO result = new PageResponseItemDTO();
		result.makePageList(pageable);
		result.setTotalPage(page.getTotalPages());
		List<Item> list = new ArrayList<>();
		page.get().forEach(item -> {
			list.add(item);
		});
		result.setItemList(list);
		return null;
	}

}
```  

### 10) Test클래스에서 테스트  
```java
@SpringBootTest
public class ServiceTest {
// ... 생략 ...
	
	@Autowired
	private ItemService itemService;
	
	// 데이터 삽입
	//@Test
	public void testregisterItem() {
		for(int i = 0; i<100; i++) {
			ItemDTO dto = ItemDTO.builder().itemname("apple_"+i).price(3000).description("사과_"+i).pictureurl("apple_"+i+".png")
					.email("dntksemfdj473@gmail.com").build();
			Long itemid = itemService.registerItem(dto);
			System.out.println(itemid);
		}
	}
	// 데이터 1개 가져오기
	//@Test
	public void testGetItem() {
		ItemDTO dto = ItemDTO.builder().itemid(101L).build();
		System.out.println(itemService.getItem(dto));
	}
	
	// 페이지 단위로 가져오기
	//@Test
	public void testGetList() {
		PageRequestItemDTO dto = PageRequestItemDTO.builder().page(2).size(10).build();
		PageResponseItemDTO result = itemService.getList(dto);
		System.out.println(result);
	}
	
	// 데이터 수정
	//@Test
	public void testUpdateItem() {
		ItemDTO dto = ItemDTO.builder().itemid(16L).itemname("apple_0616수정").price(6000).description("수정된 사과")
				.pictureurl("apple__0616수정")
				.email("dntksemfdj473@gmail.com").build();
		Long itemid = itemService.updateItem(dto);
		System.out.println(itemid);
	}
	
	// Item 삭제
	@Test
	public void testDeleteItem() {
		ItemDTO dto = ItemDTO.builder().itemid(23L).build();
		Long itemid = itemService.deleteItem(dto);
		System.out.println(itemid);
	}
}
```  
## 8. 파일 업로드 처리를 위한 설정
* 실제 제품을 만들어서 배포할 때는 이 부부은 다시 수정됩니다.  
코드가 수정되는 것은 아니고 파일 업로드 위치를 수정합니다.  
운영환경에서는 역할별로 컴퓨터를 물리적으로 분할하는 것이 일반적입니다.  
데이터베이스, 애플리케이션, 파일 저장소 등을 물리적으로 분할합니다.  

* 파일 저장소를 설정하는 방법도 예전에는 별도의 파일 서버를 이용했지만 최근에는 클라우드를 많이 이용합니다.  

* 개발자나 서비스를 구현하고자 하는 경우네는 요즈음같은 경우는 기본적인클라우드 사용법을 먼저 익히는 것이 좋습니다. 파일 서버 활용이나 데이터베이스 서버 그리고 운영환경을 만드는 부분을 공부해 두는 것이 좋습니다.  
우리나라의 경우 중소기업이나 중견기업의 경우 AWS를 압도적으로 많이 사용합니다.  
대기엽의 경우는 마이크로소프트의 애저 서비스도 이용합니다.

### 1) 업로드된 파일을 저장할 위치를 결정  

### 2) application.properties파일에 파일 업로드 관련 설정 추가  
```ini
# 파일 업로드 관련 설정
spring.servlet.multipart.enabled=true
spring.servlet.multipart.location=C:\\Users\\SAMSUNG\\Documents\\data
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=30MB

# 환경의 변화가 생겼을 떄 수정할 정적 상수를 속성으로 생성
com.choc.upload.path=C:\\Users\\SAMSUNG\\Documents\\data
```  

* +) 개발환경과 운영환경을 분리한 경우에는 개발 환경에서 운영환경으로 이전할 때(이행 - Migration) 변경될 가능성이 있는 텍스트 정보(데이터베이스 접속 위치, 파일 업로드 경로 등)는 별도의 텍스트 파일이나 데이터베이스에 보관하는 것이 좋습니다.  
내용이 변경되더라도 소스 코드를 수정하지 않고 적용을 할 수 있습니다.  
모바일에서는 documents디렉터리 이용하는 부분을 생각해봐야 합니다.  

## 9. Member요청 처리 작업  
### 1)기본 준비 작업
* 삽입, 삭제, 갱신 요청에 대한 응답을 위한 클래스를 생성 - ResponseMemberDTO: MemberDTO에 error 속성만 수정해도 됨
```java
@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ResponseMemberDTO {
	private String error;
	private String email;
	private String password;
	private String name;
	private String imageurl;
	private LocalDateTime lastlogindate;
	private LocalDateTime regdate;
	private LocalDateTime moddate;
}
``` 

* Member 요청을 처리할 MemberController를 생성하고 기본적인 구조를 생성  
```java
@RestController
@RequestMapping("member")
public class MemberController {
	@Autowired
	private MemberService memberService;
}
```  

### 2)데이터 삽입(회원 가입 처리)  
* MemberServiceImpl 클래스에 파일 업로드 경로를 가져오기 위한 속성을 추가  
```java
	//application.properties 파일에 작성한 속성 가져오기
	@Value("${com.adamsoft.upload.path}")
	private String uploadPath;
```  

* MemberServiceImpl 클래스에 이미지 파일이 업로드 될 디렉토리를 생성해주는 메서드를 생성  
```java
	//업로드한 날짜 별로 이미지를 저장하기 위해서 날짜별로 디렉토리를 만들어서 경로를 리턴하는 메서드
	private String makeFolder() {
		//오늘 날짜를 문자열로 생성
		String str = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy/MM/dd"));
		//문자열을 치환 - /를 운영체제의 디렉토리 구분자로 치환
		String realUploadPath = str.replace("//", File.separator);
		//디렉토리 생성
		File uploadPathDir = new File(uploadPath, realUploadPath);
		if(uploadPathDir.exists() == false) {
			uploadPathDir.mkdirs();
		}
		return realUploadPath;
		
	}
```  

* MemberServiceImpl 클래스에 파일 업로드를 처리하기 위해서 데이터 삽입 요청 처리 메서드를 수정  
```java
	@Override
	public String registerMember(MemberDTO dto) {
		Member member = dtoToEntity(dto);
		//이메일 중복 체크 - 별도로 구성할 수 있음
		Optional<Member> optional = memberRepository.findById(dto.getEmail());
		if(optional.isPresent()) {
			return "존재하는 이메일";
		}
		
		//이름 중복 체크 - 별도로 구성할 수 있음
		List<Member> list = memberRepository.findMemberByName(dto.getName());
		if(list.size() > 0) {
			return "존재하는 이름";
		}
		
		//파일 업로드 처리
		//전송 받은 파일을 가져오기
		MultipartFile uploadFile = dto.getImage();
		//전송된 파일이 있다면
		if(uploadFile.isEmpty() == false) {
			//이미지 파일 만 업로드하기 위해서 이미지 파일이 아니면 작업 중단
			if(uploadFile.getContentType().startsWith("image") == false) {
				return null;
			}
			//원본 파일의 파일 이름 찾아오기
			String originalName = uploadFile.getOriginalFilename();
			String fileName = originalName.substring(originalName.lastIndexOf("\\") + 1);
			
			//파일을 업로드할 디렉토리 경로를 생성
			String realUploadPath = makeFolder();
			
			//업로드 할 파일의 경로를 생성
			String uuid = UUID.randomUUID().toString(); //파일 이름의 중복을 피하기 위해서 생성
			String saveName = uploadPath + File.separator + 
					realUploadPath + File.separator + uuid + fileName;
			Path savePath = Paths.get(saveName);
			try {
				//파일 업로드
				uploadFile.transferTo(savePath);
			}catch(Exception e) {
				System.out.println(e.getLocalizedMessage());
			}
			//이미지 경로를 DTO에 설정
			dto.setImageurl(realUploadPath + File.separator + uuid + fileName);
		}
		member = dtoToEntity(dto);
		memberRepository.save(member);
		return member.getEmail();
	}
```  

* MemberController 클래스에 회원 가입 요청을 처리하는 메서드를 작성  
```java
	@PostMapping("/register")
	public ResponseEntity<?> registerMember(MemberDTO dto){
		ResponseMemberDTO response = null;
		try {
			//데이터 삽입 처리
			String email = memberService.registerMember(dto);
			response = ResponseMemberDTO.builder().email(email).build();
		}catch(Exception e) {
			String error = e.getMessage();
			response = ResponseMemberDTO.builder().error(error).build();
		}
		return ResponseEntity.ok().body(response);
	}
```  

* PostMan을 이용해서 테스트: RestController는 출력되는 화면이 없기 때문에 PostMan 같은 도구를 이용해서 테스트  

### 3) 로그인 처리  
* MemberController클래스에 로그인 요청을 처리하는 메서드 생성  
```java
	@PostMapping("/login")
	public ResponseEntity<?> loginMember(MemberDTO dto){
		ResponseMemberDTO response = null;
		try {
			//로그인 처리
			MemberDTO result = memberService.loginMemer(dto);
			if(result == null) {
				response = ResponseMemberDTO.builder()
						.error("없는 이메일이나 잘못된 비밀번호입니다.").build();
			}else {
				response = ResponseMemberDTO.builder()
						.email(result.getEmail())
						.name(result.getName())
						.imageurl(result.getImageurl())
						.regdate(result.getRegdate())
						.moddate(result.getModdate())
						.lastlogindate(result.getLastlogindate())
						.build();
			}
		}catch(Exception e) {
			String error = e.getMessage();
			response = ResponseMemberDTO.builder().error(error).build();
		}
		return ResponseEntity.ok().body(response);
	}
```

### 4) 회원 정보 가져오기  
* 회원 정보를 가져오는 메서드를 MemberController 클래스에 생성  
```java
	@GetMapping("/get")
	public ResponseEntity<?> getMember(MemberDTO dto){
		ResponseMemberDTO response = null;
		try {
			//회원 정보 가져오기
			MemberDTO result = memberService.getMemer(dto);
			if(result == null) {
				response = ResponseMemberDTO.builder()
						.error("없는 이메일입니다.").build();
			}else {
				response = ResponseMemberDTO.builder()
						.email(result.getEmail())
						.name(result.getName())
						.imageurl(result.getImageurl())
						.regdate(result.getRegdate())
						.moddate(result.getModdate())
						.lastlogindate(result.getLastlogindate())
						.build();
			}
		}catch(Exception e) {
			String error = e.getMessage();
			response = ResponseMemberDTO.builder().error(error).build();
		}
		return ResponseEntity.ok().body(response);
	}
```

### 5) 회원 정보 수정  
* MemberServiceImpl 클래스의 회원 정보 수정 메서드를 수정  
```java
	@Override
	public String updateMember(MemberDTO dto) {
		//전송된 이미지를 확인
		MultipartFile uploadFile = dto.getImage();
		//전송된 이미지가 있다면 파일 업로드
		if(dto.getImage().isEmpty() == false) {
			//이미지 파일 만 업로드하기 위해서 이미지 파일이 아니면 작업 중단
			if(uploadFile.getContentType().startsWith("image") == false) {
				return null;
			}
			//원본 파일의 파일 이름 찾아오기
			String originalName = uploadFile.getOriginalFilename();
			String fileName = originalName.substring(originalName.lastIndexOf("\\") + 1);
			
			//파일을 업로드할 디렉토리 경로를 생성
			String realUploadPath = makeFolder();
			
			//업로드 할 파일의 경로를 생성
			String uuid = UUID.randomUUID().toString(); //파일 이름의 중복을 피하기 위해서 생성
			String saveName = uploadPath + File.separator + 
					realUploadPath + File.separator + uuid + fileName;
			Path savePath = Paths.get(saveName);
			try {
				//파일 업로드
				uploadFile.transferTo(savePath);
			}catch(Exception e) {
				System.out.println(e.getLocalizedMessage());
			}
			//이미지 경로를 DTO에 설정
			dto.setImageurl(realUploadPath + File.separator + uuid + fileName);
		}else {
			//전송된 이미지가 없다면 이전 이미지 사용
			dto.setImageurl(getMemer(dto).getImageurl());
		}
		
		Member member = dtoToEntity(dto);
		memberRepository.save(member);
		return member.getEmail();
	}
```  

* MemberController 클래스에 데이터 수정 요청을 처리하는 메서드를 작성  
```java
	@PostMapping("/update")
	public ResponseEntity<?> updateMember(MemberDTO dto){
		ResponseMemberDTO response = null;
		try {
			//데이터 수정 처리
			String email = memberService.updateMember(dto);
			response = ResponseMemberDTO.builder().email(email).build();
		}catch(Exception e) {
			String error = e.getMessage();
			response = ResponseMemberDTO.builder().error(error).build();
		}
		return ResponseEntity.ok().body(response);
	}
```  

### 6) 회원 정보 삭제  
* MemberController 클래스에 한 명의 회원 정보를 삭제하는 메서드를 작성  
```java
	@PostMapping("/delete")
	public ResponseEntity<?> deleteMember(MemberDTO dto){
		ResponseMemberDTO response = null;
		try {
			//데이터 삭제 처리
			String email = memberService.deleteMember(dto);
			response = ResponseMemberDTO.builder().email(email).build();
		}catch(Exception e) {
			String error = e.getMessage();
			response = ResponseMemberDTO.builder().error(error).build();
		}
		return ResponseEntity.ok().body(response);
	}
```  

### 7) 파일 다운로드  
* MemberService 인터페이스에 파일 다운로드를 위한 메서드를 선언  
```java
public ResponseEntity<Object> download(String path);
```  

* MemberServiceImpl 클래스에 파일 다운로드를 위한 메서드를 구현  
```java
@Override
	public ResponseEntity<Object> download(String path) {
		try {
			//다운로드 받을 파일 경로를 생성
			Path filePath = Paths.get(uploadPath + File.separator + path);
			//파일 resource 가져오기
			Resource resource = 
					new InputStreamResource(
							Files.newInputStream(filePath));
			//파일 정보를 헤더에 등록
			File file = new File(path);
			HttpHeaders headers = new HttpHeaders();
			headers.setContentDisposition(
					ContentDisposition.builder("attachment")
					.filename(file.getName())
					.build());
			return new ResponseEntity<Object>(
					resource, headers, HttpStatus.OK);
			
		}catch(Exception e) {
			return new ResponseEntity<Object>(null, HttpStatus.CONFLICT);
		}
	}
```  

* MemberController 클래스에 다운로드 요청을 처리하는 메서드를 구현  
```java
	@GetMapping("/download")
	public ResponseEntity<Object> download(String path){
		return memberService.download(path);
	}
```  

## 10. Item 요청 처리 작업  
### 1) 기본 준비 작업 
* ItemDTO 클래스에 에러 메시지를 저장할 error 속성을 추가  
```java
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class PageResponseItemDTO {
	private String error;
	
	//DTO 리스트
	private List<ItemDTO> itemList;
	
	//전체 페이지 개수
	private int totalPage;
	
	//현재 페이지 번호
	private int page;
	
	//페이지 번호 목록 크기
	private int size;
	//출력할 페이지 번호 시작 과 종료
	private int start, end;
	//이전 과 다음 여부
	private boolean prev, next;
	//페이지 번호 목록
	private List<Integer> pageList;
	
	//페이지 번호 목록을 만들어주는 메서드
	public void makePageList(Pageable pageable) {
		page = pageable.getPageNumber() + 1;
		size = pageable.getPageSize();
		
		int tempEnd = (int)(Math.ceil(page/10.0)) * 10;
		start = tempEnd - 9;
		prev = start > 1;
		end = totalPage > tempEnd ? tempEnd : totalPage;
		next = totalPage > tempEnd;
		pageList = IntStream.rangeClosed(start, end)
				.boxed().collect(Collectors.toList());
	}	
}
```  

* PageResponseItemDTO 클래스를 수정 - Entity 클래스는 JSON으로 출력할 수 없으므로 Item 클래스를 ItemDTO 클래스로 변환  
```java
@Data
public class PageResponseItemDTO {
	private String error;
	
	//DTO 리스트
	private List<ItemDTO> itemList;
```  

* ItemControllerClass를 생성하고 기본 코드를 작성  
```java
@RestController
@RequestMapping("item")
@RequiredArgsConstructor
public class ItemController {
	private final ItemService itemService;
}
```  

* ItemServiceImpl 클래스에 요청을 처리하기 위한 속성 과 메서드 추가  
```java
	//application.properties 파일에 작성한 속성 가져오기
	@Value("${com.adamsoft.upload.path}")
	private String uploadPath;

	//업로드한 날짜 별로 이미지를 저장하기 위해서 날짜별로 디렉토리를 만들어서 경로를 리턴하는 메서드
	private String makeFolder() {
		//오늘 날짜를 문자열로 생성
		String str = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy/MM/dd"));
		//문자열을 치환 - /를 운영체제의 디렉토리 구분자로 치환
		String realUploadPath = str.replace("//", File.separator);
		//디렉토리 생성
		File uploadPathDir = new File(uploadPath, realUploadPath);
		if(uploadPathDir.exists() == false) {
			uploadPathDir.mkdirs();
		}
		return realUploadPath;
		
	}

	//삽입이나 수정 그리고 삭제시 작업 시간을 기록하는 메서드
	//이 시간을 읽어서 데이터가 변경되었는지 확인
	private void updateDate() {
		try(PrintWriter pw = new PrintWriter(
				new FileOutputStream("./updatedate.dat"))){
			//현재 날짜 및 시간 가져오기
			String str = LocalDateTime.now().format(
					DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
			pw.println(str);
			pw.flush();
		}catch(Exception e) {
			System.out.println(e.getLocalizedMessage());
		}
	}
```  

### 2) 페이지 단위로 데이터 가져오기  
* ItemServiceImpl 클래스이 요청 처리 메서드 수정  
```java
	@Override
	public PageResponseItemDTO getList(PageRequestItemDTO dto) {
		Sort sort = Sort.by("itemid").descending();
		Pageable pageable = PageRequest.of(
				dto.getPage()-1, dto.getSize(), sort);
		Page<Item> page = itemRepository.findAll(pageable);
		
		PageResponseItemDTO result = new PageResponseItemDTO();
		result.makePageList(pageable);
		result.setTotalPage(page.getTotalPages());
		List<ItemDTO> list = new ArrayList<>();
		page.get().forEach(item -> {
			list.add(entityToDto(item));
		});
		result.setItemList(list);
		return result;
	}
```  

* ItemController 클래스에 페이지 단위 요청을 처리하는 메서드를 구현  
```javva
	//페이지 단위로 데이터 가져오기
	@GetMapping("list")
	public ResponseEntity<?> getList(PageRequestItemDTO dto){
		PageResponseItemDTO response = null;
		try {
			response = itemService.getList(dto);
		}catch(Exception e) {
			response = new PageResponseItemDTO();
			response.setError(e.getMessage());
		}
		return ResponseEntity.ok().body(response);
	}
```  

### 3) 데이터 삽입 요청 처리  
* ItemServiceImpl 클래스에서 데이터 삽입을 처리하는 메서드를 수정  
```java
	@Override
	public Long registerItem(ItemDTO dto) {
		//파일 업로드 처리
		//전송 받은 파일을 가져오기
		MultipartFile uploadFile = dto.getImage();
		//전송된 파일이 있다면
		if(uploadFile.isEmpty() == false) {
			//이미지 파일 만 업로드하기 위해서 이미지 파일이 아니면 작업 중단
			if(uploadFile.getContentType().startsWith("image") == false) {
				return null;
			}
			//원본 파일의 파일 이름 찾아오기
			String originalName = uploadFile.getOriginalFilename();
			String fileName = originalName.substring(originalName.lastIndexOf("\\") + 1);
			
			//파일을 업로드할 디렉토리 경로를 생성
			String realUploadPath = makeFolder();
			
			//업로드 할 파일의 경로를 생성
			String uuid = UUID.randomUUID().toString(); //파일 이름의 중복을 피하기 위해서 생성
			String saveName = uploadPath + File.separator + 
					realUploadPath + File.separator + uuid + fileName;
			Path savePath = Paths.get(saveName);
			try {
				//파일 업로드
				uploadFile.transferTo(savePath);
			}catch(Exception e) {
				System.out.println(e.getLocalizedMessage());
			}
			//이미지 경로를 DTO에 설정
			dto.setPictureurl(realUploadPath + File.separator + uuid + fileName);
		}
		
		Item item = dtoToEntity(dto);
		itemRepository.save(item);
		//수정한 시간을 기록
		updateDate();
		return item.getItemid();
	}
```  

* ItemController 클래스에 데이터 삽입 요청을 처리하는 메서드를 생성  
```java
	//데이터 삽입
	@PostMapping("register")
	public ResponseEntity<?> registerItem(ItemDTO dto){
		ItemDTO response = null;
		try {
			Long itemid = itemService.registerItem(dto);
			response = ItemDTO.builder().itemid(itemid).build();
		}catch(Exception e) {
			response = ItemDTO.builder().error(e.getMessage()).build();
		}
		
		return ResponseEntity.ok().body(response);
	}
```  	

### 4) 데이터 1개 가져오기  
* ItemController 클래스에 데이터 1개를 가져오는 메서드를 구현  
```java
	//데이터 1개 가져오기
	@GetMapping("get")
	public ResponseEntity<?> getItem(ItemDTO dto){
		ItemDTO response = null;
		try {
			response = itemService.getItem(dto);
		}catch(Exception e) {
			response = ItemDTO.builder().error(e.getMessage()).build();
		}
		
		return ResponseEntity.ok().body(response);
	}
```  

### 5) 데이터 삭제  
* ItemServiceImpl 클래스의 데이터 삭제 메서드 수정  
```java
	@Override
	public Long deleteItem(ItemDTO dto) {
		Item item = dtoToEntity(dto);
		Long itemid = item.getItemid();
		itemRepository.deleteById(itemid);
		updateDate();
		return itemid;
	}
``` 

* ItemController 클래스에 데이터 삭제 요청 처리 메서드 작성  
```java
	//데이터 삭제
	@PostMapping("delete")
	public ResponseEntity<?> deleteItem(ItemDTO dto){
		ItemDTO response = null;
		try {
			Long itemid = itemService.deleteItem(dto);
			response = ItemDTO.builder().itemid(itemid).build();
		}catch(Exception e) {
			response = ItemDTO.builder().error(e.getMessage()).build();
		}
		
		return ResponseEntity.ok().body(response);
	}
```  

### +) 엔지니어링 방식  
* Forward Engineering  

* Reverse Engineering  

### 6) 데이터 수정
* ItemServiceImpl 클래스의 데이터 수정을 위한 메서드 수정  
```java
@Override
	public Long updateItem(ItemDTO dto) {
		// 삽입할 때는 이미지가 없으면 이미지 업로드를 처리하지 않거나 기본 이미지로 설정
		// 수정을 할 때 이미지가 없다는 것은 수정할 이미지가 없다는 의미가 될 수 있음
		if(dto.getImage().isEmpty() == false) {
			// 업로드된 파일을 가져오기
			MultipartFile uploadFile = dto.getImage();
			
			// 원본 파일 이름 찾아오기
			String originalName = uploadFile.getOriginalFilename();
			// IE나 Edge에서는 전체 파일 경로가 오기 때문에 마지막 \위치를 찾아서 뒷부부만 가져와야 합.
			String fileName = originalName.substring(originalName.lastIndexOf("\\")+1); // 모바일에서 이 작업은 안해도 됨
			
			// 업로드할 디렉터리 경로를 생성, 회원 정보 이미지와 아이템 이미지를 구별해서 ㅅ저장하고자 하면 makeFolder 메서드를 각ㄱ각 구현
			String realUploadPath = makeFolder();

			// 파일 이름 중복을 최소화하기 위한 UUID 생성
			String uuid = UUID.randomUUID().toString();
			// 파일 이름 중간에 _를 이용해서 구분
			// 교재나 검색한 소스가 보일 때 \나 /가 보이면 앞뒤 문맥을 읽어서 디렉터리 기호라면 File.separator로 변경하는 것을 고려
			// 고재를 볼 때는 어떤 운영체제에서 작성한 것인지 확인하고 교재를 읽어보는 것이 좋습니다. 
			String saveName = uploadPath + File.separator + realUploadPath + File.separator + uuid + fileName;
			// 실제 전송할 경로를 생성 - jdk 1.7 이상에서 지원
			Path savePath = Paths.get(saveName);
			
			try {
				// 파일 전송
				uploadFile.transferTo(savePath);
			}catch(Exception e) {
				System.out.println(e.getLocalizedMessage());
				e.printStackTrace();
			}
			// 파일의 경로를 저장
			dto.setPictureurl(realUploadPath + File.separator + uuid + fileName);
		}else {
			// 업로드할 파일이 없을 때 이전 내용을 그대로 적용
			dto.setPictureurl(getItem(dto).getPictureurl());
		}
		
		// 데이터베이스에서 수정
		Item item = dtoToEntity(dto);
		Long itemid = item.getItemid();
		itemRepository.save(item);
		// 수정한 날짜 업데이트
		updateDate();
		return itemid;
	}
```  

* +) IOT 분야에서 대부분의 경우는 Linux 기반의 운영체제를 많이 사용합니다.  
의료기기같은 분야에서는 Windows도 많이 사용합니다.  
개발할 때 운영환경과 개발환경이 다를 수 있음을 항상 기억하기.  
Java의 가장 큰 장점 : WORA(Write Once Run Anywhere), 플랫폼 독립적 

* ItemController클래스에 데이터를 수정하는 요청을 처리하는 메서드 생성  
```java
// 데이터 수정
	@PostMapping("update")
	public ResponseEntity<?> updateItem(ItemDTO dto){
		ItemDTO response = null;
		try {
			Long itemid = itemService.updateItem(dto);
			response = ItemDTO.builder().itemid(itemid).build();
		}catch (Exception e) {
			response = ItemDTO.builder().error(e.getMessage()).build();
		}
		return ResponseEntity.ok().body(response);
	}
```  

* PostMan으로 테스트

* +) 데이터베이스 제약조건  
	Constraint(제약조건) : 데이터를 안전하게 보호하기 위해서 지켜야할 조건  
	개체 무결성 제약조건(Entity Integerity Constraint) : 기본키는 null이거나 중복될 수 없다.  
	참조 무결성 제약조건(Referential Integrity Constraint) : 외래키는 참조할 수없는 값을 가질 수 없다. 외래키 값은 참조하는 테이블에 존재하는 값이나 null이어야 한다.  

	UNIQUE  
	NOT NULL  
	CHECK(도메인 제약 조건) - @Valid를 이용해서 Spring에서는 검사가 가능합니다. 유효성 것마를 하고자 할 때는 반드시 정규 표현식을 조금 학습하셔야 합니다.  

 * +) QA : 테스트와 품질 관리
	black box test : 기능을 검사, equivalence partitioning 기능이 제대로 동작하는 상황과 그렇지 않은 상황을 동등하게 테스트  

	white box test : 내부 구조를 검사 - 반복문이나 분기문등을 검사  

	알파테스트 : 개발자의 환경에서 제대로 동작하는지 코드를 테스트  
	베타테스트 : 사용자의 환경에서 제대로 동작하는지 코드를 테스트  

### 7) 마지막 업데이트 된 시간 저장  
* +) 최근의 프로그래밍에서는 Edge Computing이 매우 중요하게 취급됩니다. 데이터 발생지에서 직접 처리하는 방식입니다.  

	실제 서비스에서는 트래픽을 어떻게 최소화하는지에 대한 부분도 중요합니다.  
	클라이언트 - 서버 방식의 애플리케이션에서는 아주 중요한 부분 중의 하나입니다.  
	클라이언트에 일정 부분의 데이터를 저장하고 데이터가 변경된 경우에만 다운로드받아서 사용하는 방식을 많이 구현합니다.  
	이런 방식의 구현을 할 때 서버의 데이터와 클라이언트가 로컬에 소유하고 있는 데이터와 다른지 구별을 해야 하는데, 이 방식 중의 하나가 서버에는 데이터가 변경된 시간을저장해두고 클라이언트에게 전송할 수 있도록 하는 것이고, 클라이언트에서는 무조건 데이터를 다운로드 받는 것이 아니고 자신에게 저장된 마지막 다운로드 시간과 서버의 마지막 업데이트 시간을 비교해서 데이터를 업데이트하는 것입니다.  
	이렇게 구현을 하면 클라이언트의 네트워크가 되지 않는 상황에서도 로컬에 저장된 데이터를 사용할 수 있습니다.  

	드물기는 하지만 파일의 크기를 가지고 비교하는 경우도 있습니다.  

* ItemService인터페이스에 마지막 수정시간을 전송하는 메서드를 선언  
```java
	// 마지막 업데이트된 시간을 전송하는 메서드  
	public String updatedate();
```  

* ItemServiceImpl클래스에 마지막 수정 시간을 전송하는 메서드를 구현  
```java
	@Override
	public String updatedate() {
		try(BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("./updatedate.dat")))){
			String str = br.readLine();
			return str;
			// return br.readLine();
		}catch(Exception e) {
			System.out.println(e.getLocalizedMessage());
			return null;
		}
	}
```  

### +) 앱 개발 방법  
* Native app 개발을 위한 IDE에서 개발
	Android Studio나 Xcode에서 개발, 여러 종류의 애플리케이션을 만들려면 여러 언어를 습득해야 한다는 단점이 있지만 스마트 디바이스의 모든 API를 전부 사용할 수 있으며 디버깅이 쉽고, 많은 개발 문서를 지원

* 하이브리드 앱 개발  
	Android Studio나 XCode가 아닌 다른 방법을 이용해서 2가지 종류 이상의 운영체제에서 동작하는 애플리케이션을 동시에 개발하는 방법  
	react-native(javascript 기반 - typescript와 react의 선행 필요), flutter(Dart 기반)
	단점 : 프레임워크 업데이트가 자주 발생하기 때문에 개발이 어려워질 수 있지만 빠르게 여러 종류의 애플리케이션을 만들 수 있다는 장점이 있음  

* Mobile Web 개발
	Mobile Web 애플리케이션을 구축하고 스마트 디바이스의 브라우저에서 접속하던가 스마트 디바이스에 Web View를 배치하고 Mobile Web에 접속하는 방법, 최근에는 Web View만으로 구성된 애플리케이션은 마켓에서 reject됩니다.  

## 11. SmartPhone Application 제작 - Android  
### 1) Android Studio에서 프로젝트를 생성  

* 화면 구성 단위  
Android : Activity -> Fragment -> View -> Layer(거의 사용하지 않음)  
iOS : ViewController -> View -> Layer  
react : Compnent

* 화면 작업 방법  
Android : XML과 java(kt)파일이 하나의 쌍으로 존재해서 XML파일에 디자인을 하고 java파일에서 불러서 사용하는 방식을 많이 이용. XML없이도 가능  
iOS : Storyboard를 이용 가능, Interface Builder를 이용해서 XML로 생성한 후 swift파일에서 불러서 사용, 최근에는 Swift UI라고 해서 새로운 방식으로 디자인 하기도 함.
react : JSX문법으로 화면을 디자인  

* 리소스 관리
Android : 리소스와 코드를 엄격하게 구분하고 리소스를 저장하는 디렉터리의 이름이 용도를 결정하는 경우가 많음. 리소스를 하나의 정수형 상수로 변환해서 사용할 수 있도록 하기 때문  
iOS,react : 리소스를 소스코드와 구별하지 않음.  

### 2) 인터넷 권한 설정  
* 준비 작업
서버의 데이터를 사용하기 위해서는 인터넷 권한을 설정해야 함  
서버의 프로토콜이 http인 경우는 별도의 설정을 추가해야 합니다.  
iOS의 경우는 인터넷 권한은 기본적으로 주어지지만 http에 접속하는 경우는 역시 별도의 수정이 추가되어야 합니다.  

* AndroidManifest.xml 파일을 수정  
```xml
    <!-- 인터넷 권한 추가 -->
    <uses-permission android:name="android.permission.INTERNET"/>
```

### 3) 페이지단위로 데이터 가져오기 구현  
* 1. 화면 디자인을 수정 - res/layout/main_activity.xml파일을 수정  
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity"
    android:orientation="horizontal">

    <TextView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:text="ITEM LIST"
        android:textSize="32sp"
        android:gravity="center"
        android:background="@color/teal_200"
         />
    <ProgressBar
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:id="@+id/downloadview"
        />

    <ListView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:id="@+id/listview"
        />

</LinearLayout>
```  

* +) 안드로이드에서 뷰의 종류  
	Layout : 여러 개의 뷰를 모아놓은 뷰이며 Adapter클래스와 연동해서 데이터를 출력하는 뷰도 layout에 속함  

	Layout이 없는 뷰  

* 하나의 데이터를 표현하기 위한 클래스 생성 - item.java
```java
package com.chocchic;

import java.io.Serializable;

public class Item implements Serializable {
    public Long getItemid() {
        return itemid;
    }

    public void setItemid(Long itemid) {
        this.itemid = itemid;
    }

    private Long itemid;

    public String getItemname() {
        return itemname;
    }

    public void setItemname(String itemname) {
        this.itemname = itemname;
    }

    private String itemname;

    public Integer getPrice() {
        return price;
    }

    public void setPrice(Integer price) {
        this.price = price;
    }

    private Integer price;

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public String getPictureurl() {
        return pictureurl;
    }

    public void setPictureurl(String pictureurl) {
        this.pictureurl = pictureurl;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    private String description;
    private String pictureurl;

    public String getEmail() {
        return email;
    }
    @Override
    public String toString() {
        return "Item{" +
                "itemid=" + itemid +
                ", itemname='" + itemname + '\'' +
                ", price=" + price +
                ", description='" + description + '\'' +
                ", pictureurl='" + pictureurl + '\'' +
                ", email='" + email + '\'' +
                '}';
    }	
    private String email;
}
```  

* 서버로부터 받은 데이터를 로컬 데이터베이스(SQLite3)에 저장하기 위한 Helper클래스 생성 - ItemDB.java  
```java
public class ItemDB extends SQLiteOpenHelper {

    // 생성자
    // Context는 어떤 정보를 저장한 객체를 의미
    // 안드로이드에서는 context를 매개변수로 하는 메서드가 많은데, Context를 대입하라고 하면 Activity클래스의 인스턴스를 대입하면 됩니다.
    
    public ItemDB(@Nullable Context context) {
        // 상위 클래스의 생성자 호출
        super(context, "item.db", null, 1);
    }
    
    // 앱을 설치할 때 호출되는 메서드
    // 여기서는 필요한 테이블을 생성
    @Override
    public void onCreate(SQLiteDatabase db) {
        // 테이블 생성 구문
        db.execSQL("create table item(itemid integer primary key, itemname, price integer, description, pictureurl, email)");
    }

    // 업그레이드될 때 호출되는 메서드
    // 여기서는 테이블을 삭제하고 새로 생성하는 코드를 주로 작성
    @Override
    public void onUpgrade(SQLiteDatabase db, int i, int i1) {
        db.execSQL("DROP TABLE IF EXISTS item");
        onCreate(db);
    }
```  

* ListView의 하나의 셀을 위한 디자인을 저장할 파일을 생성 - res/layout/item_cell.xml  
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="horizontal">
    <LinearLayout
        android:layout_width="0dp"
        android:layout_height="100dp"
        android:layout_weight="5"
        android:orientation="vertical"
        >
        <TextView
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_weight="1"
            android:id="@+id/itemname"
            android:text="아이템 이름"
            android:textSize="20dp"/>
        <TextView
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_weight="1"
            android:id="@+id/price"
            android:text="아이템 가격"
            android:textSize="20dp"/>
    </LinearLayout>
    <ImageView
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="5"
        android:id="@+id/itemimage"/>
</LinearLayout>
```  
-> Android나 iOS에서는 여러 개의 데이터 목록을 출력하는 Android에서는 ListView, iOS에서는 UITableView를 제공하는데 각 셀을 자신이 원하는 형태로 변경할 수 있다.  

* ListView에 데이터와 셀을 연결해주는 클래스를 생성 - ItemAdapter  
```java
// 아이폰은 implements, 안드로이드는 extends
public class ItemAdapter extends BaseAdapter {
    // AdapterView 출력을 위한 속성
    // ** 셀을 만들기 위해서 필요한 정보 ** //
    // layoutInflater를 만들기 위한 문맥 정보
    Context context;
    // xml로 만든 레이아웃을 뷰로 전개하기 위한 객체
    LayoutInflater inflater;
    // layout File의 파일의 이름
    int layout;
    // 출력할 데이터의 List
    List<Item> data;

    // 생성자
    public ItemAdapter(Context context, List<Item> data, int layout){
        super();
        this.context = context;
        this.data = data;
        this.layout = layout;

        inflater = (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    }
    // 행의 개수를 설정하는 메서드
    @Override
    public int getCount() {
        return data.size();
    }
    // 항목에 보여질 문자열을 설정하는 메서드
    // 아래 2개 메서드는 getCount에서 리턴한 개수만큼 반복해서 수행
    @Override
    public Object getItem(int i) {
        return data.get(i).getItemname();
    }

    @Override
    public long getItemId(int i) {
        return data.get(i).getItemid();
    }

    // 실제 셀의 모양을 결정하는 메서드
    // i는 각 셀의 인덱스, View는 화면에 보여지는 뷰로 처음에는 null이 넘어오고 두 번째부터 이전에 출력한 뷰가 넘어옴.
    // viewGroup은 이 항목을 사용하는 AdapterView
    @Override
    public View getView(int i, View view, ViewGroup viewGroup) {
        // 매개변수로 넘어온 변수를 다른 변수나 final 변수에 저장하는 경우
        final int pos = i;

        // 이전에 출력된 뷰가 없다면 뷰를 생성
        if(view == null){
            view = inflater.inflate(layout, viewGroup, false);
        }

        //  i 번째 데이터 찾아오기
        Item item = data.get(i);

        // 데이터 출력
        TextView txtName = (TextView)view.findViewById(R.id.itemname);
        txtName.setText(item.getItemname());

        TextView txtPrice = (TextView)view.findViewById(R.id.price);
        txtPrice.setText(item.getPrice()+"원");

        ImageView imageView = (ImageView)view.findViewById(R.id.itemimage);

        Handler handler = new Handler(Looper.getMainLooper()) {
           public void handleMessage(Message msg){
                // 스레드가 전달한 데이터 읽기
               Bitmap bitmap = (Bitmap)msg.obj;
               // 이미지 뷰에 이미지 출력
               imageView.setImageBitmap(bitmap);
           }
        };

        class ThreadEx extends Thread {
            public void run(){
                // 이미지를 다운로드
                try{
                    // 이미지를 웹 서버의 이미지 다운로드 경로에서 스트림으로 연결
                    // 문자열을 제외한 모든 데이터의 다운로드
                    InputStream inputStream = new URL("http://192.168.0.9:80/member/download?path="
                            + item.getPictureurl()).openStream();
                    // 이미지의 경우는 다운로드받은 내용을 Bitmap으로 변환
                    // 이미지가 아닌 경우라면 Stream의 내용을 읽어서 파일로 저장해야 함
                    Bitmap bitmap = BitmapFactory.decodeStream(inputStream);

                    // 핸들러에게 데이터를 전달하기 위해서 Message객체를 생성
                    Message msg = new Message();
                    msg.obj = bitmap;
                    
                    // 핸들러에게 순서대로 작업을 수행하도록 요청
                    handler.sendMessage(msg);
                }catch (Exception e){
                    Log.e("다운로드 예외",e.getLocalizedMessage());
                }
            }
        }

        new ThreadEx().start();

        return view;
    }
}
```  
	+ Android는 여러 개의 데이터를 출력하기 위한 뷰를 Adapter View 또는 Collection View라고 하는데, Adapter View는 데이터를 공급해주고 출력하는 메서드를 가진 Adapter클래스와 화면 출력을 위한 View클래스로 구분됩니다.  
	+ 메서드의 매개변수를 다른 변수에 저장하는 이유 : 메서드의 수행이 종료된 후에 이 변수를 이용하기 위해서  
	+ 메서드의 매개변수를 final 변수에 저장하는 이유 : annonymous class에서는 메서드의 지역변수를 사용할 수 없는데, 예외적으로 final변수는 사용할 수 있음  
	+ 안드로이드에서는 네트워크 자원을 사용할 때 반드시 스레드를 이용해야 합니다.  
	+ 안드로이드를 비롯한 GUI 프로그래밍에서는 메인 스레드에서만 UI 갱신을 할 수 있습니다.  
		- 안드로이드는 메인 스레드가 아니면 Handler를 이용해서 UI 갱신을 수행합니다.  
		- 서버에서 데이터를 다운로드 받아서 화면에 출력하고자 할 때는 스레드와 핸들러를 이용해야 합니다. 이 메커니즘은 거의 모든 GUI 프로그래밍에서 그대로 적용됩니다. iOS는 핸들러 대신 다른 용어를 사용하지만 원리는 같음  
		- HTML5에서도 Thread와 유사한 Worker라고 하는 API가 추가되었는데, Worker에서는 UI 갱신을 할 수 없고, Main화면에 메세지를 전송해서 UI를 갱신하도록 해주어야 합니다.  
	+ Handler에게 전송하는 것은 Main Thread의 MessageQueue라고 명렁 처리 시스템에 작업 내용을 전송하는 형태라서 
	+ 안드로이드에서 localhost는 안드로이드 기기 자체이므로 안드로이드에서 현재 컴퓨터에 접속을 할 때는 IP를 사용해야 합니다. 스마트 디바이스는 자신이 하나의 컴퓨터라는 것을 잊지 말기  


* +) 메인 화면에서 데이터를 가져와서 출력하는 메커니즘  
	로컬에 저장된 파일에서 최종 업데이트한 시간을 가져오고 서버의 업데이트한 시간을 가져와서 두개의 시간이 다르면 서버에서 데이터를 다운로드 받아서 로컬 데이터베이스에 저장하고, 출력하고 두개의 시간이 같으면 로컬 데이터베이스의 데이터를 출력  
	
	기본적으로 데이터는 첫 번째 페이지의 15개의 데이터를 가져옵니다.  
	
	ListView 하단에서 스크롤을 하면 다음 페이지의 데이터가 있는 경우 다음 페이지의 데이터를 가져옵니다.  

	PullToRefresh 구현 : 상단에서 하단으로 드래그하면 데이터를 최신의 것으로 업데이트  

* +) 화면출력과 서버 연동을 할 때 수행할 작업  
	전체 데이터 가져와서 출력하기  

	페이지 단위로 데이터를 가져와서 출력한 후 다음 페이지의 데이터나 변경된 데이터 적용  

	데이터를 출력할 때, 이미지 파일의 출력과 다른 종류의 파일의 경우는 다운로드  

	클라이언트에서 GET방식으로 요청하는 것과 POST방식에서 File이 있는 경우와 없는 경우의 전송 처리  

	서버 쪽에서는 클라이언트의 요청 전과 후의 특정 작업을 수행하는 것  

* MainActivity에 변수 추가
```java
	// 최종 업데이트 시간을 저장하기 위한 변수
    private String updateTime;

    // 현재 페이지 번호, 한 페이지당 데이터 개수, 전체 페이지 개수를 저장할 변수
    private int page;
    private int size;
    private int totalPage;

    // 로컬 데이터베이스 변수
    private ItemDB itemDB;

    // 데이터 목록을 저장할 List
    private List<Item> list;

    // 화면에 보여지는 뷰를 위한 변수
    private ProgressBar downloadview;
    private ListView listView;

    // ListView에 데이터를 공급해줄 Adapter
    private ItemAdapter itemAdapter;
```

* +) List 구조
	Array : 크기가 고정 - 크기 변경이 안됨
	ArrayList : 순서대로 저장하는데 크기 변경이 가능  
	LinkedList : 논리적인 순서대로 저장 - 삽입, 삭제, 갱신 작업에는 유리하지만 조회 작업에 불리하고 메모리 낭비가 생길 수 있음  
	Stack : LIFO(Last In First Out)  
	Queue : FIFO(First In First Out) - 스케쥴링  
	Deque : 양쪽에서 삽입과 삭제가 발생하는 자료구조 - 스마트폰의 지도나 데이터를 출력하는 CollectionView  

	트리 : 순회
	그래프 : BFS, DFS  

* MainActiviy.java파일에 데이터를 출력하는 핸들러를 생성  
```java
   //Looper 는 메시지 시스템
    //메인 스레드에게 요청을 전송하는 핸들러
    Handler handler = new Handler(Looper.getMainLooper()){
        //java에서 메서드 오버라이딩을 할 때 되도록이면 @Override를
        //습관적으로 붙이는 것이 좋습니다.
        //메서드의 추상 여부 와 추상이 아닌 경우 어떤 작업을 하는지 확인
        @Override
        public void handleMessage(Message message){
            //하단이나 상단에 출력되는 메시지 박스가 Snackbar
            Snackbar.make(MainActivity.this.getWindow().getDecorView(),
                    "데이터 업데이트", Snackbar.LENGTH_LONG);
            //ListView 에 출력할 데이터 공급자 생성
            //클래스 안에서 this를 하게 되면 인스턴스 자신
            //anonymous 클래스에 안에서 this를 하게되면 anonymous 클래스의 인스터스
            //내부 클래스 안에서 외부 클래스 인스턴스를 사용하고자 할 때는
            //클래스이름.this를 이용하면 됩니다.
            itemAdapter = new ItemAdapter(MainActivity.this,
                    list, R.layout.item_cell);
            //ListView 와 Adapter를 연결
            //데이터가 변경되면 itemAdapter.notifyDataSetChanged()를 호출
            listView.setAdapter(itemAdapter);
            //프로그래스 뷰를 화면에서 제거
            downloadview.setVisibility(View.GONE);
            
            //현재 시간을 파일에 기록
            try{
                //안드로이드에서 파일에 기록하는 작업은 Data 디렉토리에서만 가능한데
                //openFileOutput을 호출하면 Data 디렉토리에 대한 경로 설정을 해줍니다.
                FileOutputStream fos = openFileOutput("updatetime.txt", 
                        Context.MODE_PRIVATE);
                fos.write(updateTime.getBytes());
                fos.close();
            }catch(Exception e){
                Log.e("업데이트 오류", "업데이트 한 시간을 기록하지 못함");
            }
            
        }
    };
```  

* MainActivity.java파일에 데이터를 다운로드 받거나 로컬에서 읽어서 ListView에 출력하도록 핸들러를 호출하는 스레드를 생성  
```java
    //출력하기 위한 데이터를 만드는 스레드
    class DataDisplayThread extends Thread{
        //다운로드 받은 문자열을 저장하기 위한 변수
        StringBuilder sb = new StringBuilder();

        //스레드로 수행할 내용
        public void run(){
            try{
                //업데이트 한 시간 가져오기 - GET 방식, 파라미터 없음음
                URL url = new URL("http://192.168.10.8:9000/item/updatedate");
                //URL에 연결
                HttpURLConnection con = (HttpURLConnection)url.openConnection();
                //옵션 설정
                con.setUseCaches(false);//캐싱된 데이터 사용 여부
                con.setConnectTimeout(30000);//최대 접속 요청 시간 - 30초

                //스트림 생성 - 문자열을 다운로드 받기 위한 스트림
                BufferedReader br = new BufferedReader(
                        new InputStreamReader(con.getInputStream()));
                //문자열이 아닌 파일 다운로드
                //InputStream is = con.getInputStream();

                //문자열 읽기
                while(true){
                    String line = br.readLine();
                    if(line == null){
                        break;
                    }
                    sb.append(line + "\n");
                }
                br.close();
                con.disconnect();
                //중간에 다운로드 받은 내용을 출력
                Log.e("다운로드 받은 문자열", sb.toString());
                //다운로드 받은 문자열이 csv 나 XML, JSON, YML 이라면 파싱을 해야 하고
                //아니면 바로 사용 가능

                //JSON 파싱
                //다운로드 받은 문자열이 { }로 감싸져 있어서 JSONObject 로 생성
                //[ ]로 감싸져 있으면 JSONArray 로생성
                JSONObject object = new JSONObject(sb.toString());
                //updatedate 키의 값을 문자열로 가져오기
                String serverUpdateTime = object.getString("updatedate");
                //서버의 업데이트 시간을 updateTime에 대입
                updateTime = serverUpdateTime;

                String localUpdateTime = null;
                //로컬의 업데이트 타임을 구하기
                try{
                    FileInputStream fis = openFileInput("updatetime.txt");
                    byte[] data = new byte[fis.available()];
                    fis.read(data);
                    fis.close();
                    localUpdateTime = new String(data);
                }catch(Exception e){
                    Log.e("업데이트 파일", "업데이트 시간이 기록된 파일이 없음");
                }
                if(serverUpdateTime.equals(localUpdateTime)){
                    Log.e("업데이트 한 시간 비교", "시간이 같으므로 다운로드 할 필요 없음");

                    //전체 페이지 개수를 업데이트 - 전체 데이터가 몇개인지 읽어옵니다.
                    FileInputStream fis = openFileInput("totalpage.txt");
                    byte[] data = new byte[fis.available()];
                    fis.read(data);
                    totalPage = Integer.parseInt(new String(data));
                    fis.close();

                }else{
                    Log.e("업데이트 한 시간 비교", "시간이 다르므로 데이터를 다운로드");
                    //데이터를 다운로드 받을 위치 설정
                    url = new URL("http://192.168.10.8:9000/item/list?page="
                            + page + "&size=" + size);
                    con = (HttpURLConnection)url.openConnection();
                    con.setUseCaches(false);
                    con.setConnectTimeout(30000);

                    br = new BufferedReader(new InputStreamReader(con.getInputStream()));
                    sb = new StringBuilder();
                    while(true){
                        String line = br.readLine();
                        if(line == null){
                            break;
                        }
                        sb.append(line + "\n");
                    }
                    br.close();
                    con.disconnect();
                    Log.e("다운로드 받은 데이터", sb.toString());

                    //JSON 파싱
                    object = new JSONObject(sb.toString());
                    //전체 페이지 개수 가져오기
                    totalPage = object.getInt("totalPage");
                    //전체 페이지 개수를 파일에 저장
                    //서버 와 클라이언트의 업데이트한 날짜가 같은 경우 서버의 데이터를 받아오지 않기 때문에
                    //몇 개의 페이지가 있는지 알지 못하기 때문에
                    //전체 페이지 개수를 파일에 저장을 해 놓아야 스크롤 여부를 결정할 수 있습니다.
                    FileOutputStream fos = openFileOutput(
                            "totalpage.txt", Context.MODE_PRIVATE);
                    fos.write((""+totalPage).getBytes());
                    fos.close();

                    //아이템 목록 가져오기
                    JSONArray ar = object.getJSONArray("itemList");

                    //로컬 데이터베이스 연결
                    SQLiteDatabase db = itemDB.getWritableDatabase();
                    //Item 테이블의 모든 데이터 삭제
                    db.delete("item", null, null);
                    //순회
                    for(int i=0; i<ar.length(); i++){
                        JSONObject item = ar.getJSONObject(i);

                        //ContentValues(Map 처럼 사용하지만 Entity처럼 동작)
                        //를 이용해서 데이터 삽입, 수정, 삭제가 가능
                        ContentValues row = new ContentValues();
                        row.put("itemid", item.getLong("itemid"));
                        row.put("itemname", item.getString("itemname"));
                        row.put("price", item.getInt("price"));
                        row.put("description", item.getString("description"));
                        row.put("pictureurl", item.getString("pictureurl"));
                        row.put("email", item.getString("email"));

                        //item 테이블에 데이터 삽입
                        db.insert("item", null, row);

                    }
                }

                //SQLite 데이터베이스에서 데이터를 읽어서 itemList에 저장

                //데이터베이스에서 데이터 읽기
                SQLiteDatabase db = itemDB.getReadableDatabase();
                //Cursor 는 Iterable, Enumeration 과 유사한데
                //next()를 이용해서 다음 데이터를 찾아가는 방식으로 동작하고
                //읽은 데이터가 없으면 false를 리턴
                Cursor cursor = db.rawQuery(
                        "select itemid, itemname, price, description, pictureurl, email " +
                                "from item order by itemid desc", null);
                //데이터를 저장할 List 클리어
                list.clear();

                //커서 순회
                while(cursor.moveToNext()){
                    Item item = new Item();
                    item.setItemid(cursor.getLong(0));
                    item.setItemname(cursor.getString(1));
                    item.setPrice(cursor.getInt(2));
                    item.setDescription(cursor.getString(3));
                    item.setPictureurl(cursor.getString(4));
                    item.setEmail(cursor.getString(5));

                    list.add(item);
                }

                Log.e("list", list.toString());
                //Message 생성
                Message message = new Message();
                //핸들러에게 메시지를 전송
                //handler의 handleMessage 가 호출됩니다.
                handler.sendMessage(message);

            }catch(Exception e){
                Log.e("데이터 다운로드 예외", e.getLocalizedMessage());
            }
        }
    }
```  

* MainActivity.java파일의 특정 이벤트 처리 코드에서 스레드를 생성하고 시작하도록 작성  
```java  
    @Override
    //Activity가 만들어지면 호출되는 메서드
    //화면을 초기화하고 설정하는 작업을 수행
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //페이지 번호 와 한 페이지에 보여질 데이터 개수 초기화
        page=1;
        size=15;
        //데이터베이스 객체 생성
        itemDB = new ItemDB(this);
        //List 초기화
        list = new ArrayList<>();

        //뷰 찾아오기
        listView = (ListView)findViewById(R.id.listview);
        downloadview = (ProgressBar)findViewById(R.id.downloadview);

        //기본 출력을 위한 Adapter 생성 과 설정
        itemAdapter = new ItemAdapter(this, list, R.layout.item_cell);
        listView.setAdapter(itemAdapter);

        //스레드를 만들어서 실행
        new DataDisplayThread().start();
    }
```  

* +) Thread의 우선 순위  
	MAX_PRIORITY  
	NORMAL_PRIORITY  
	MIN_PRIORITY  

* +) 자바에서의 입출력  
	자바에서는 Stream을 이용해서 하는데, 바이트 단위로 통신을 수행한다.  
	단방향 통신을 수행 : InputStream, OutputStream이 존재  
	파일과 통신을 수행할 때는 FileInputStream, FileOutputStream을 이용  

	문자 단위로 통신을 하고자 하는 경우는 Stream을 기반으로 해서 Reader와 Writer를 이용해서 작성,  
	파일과 문자 단위로 통신을 하고자 하는 경우는 FileReader나 FileWriter를 만들면 됩니다.  

	파일이나 네트워크를 통해서 입출력을 하는 작업은 Native Method를 호출합니다.  

	HW <-> OS(운영체제) <-> Application  
	HW <-> OS(운영체제) <-> JVM <-> Java Application  

	Native Method는 운영체제에게 명령을 수행하도록 하는 메서드를 의미합니다.  
	입출력을 할 때마다 Native Method를 호출하게 되면 너무 빈번한 Native Method 호출로 인해 시스템 효율이 나빠질 수 있음  

	입출력할 내용을 모아서 처리하도록 입출력 내용을 저장하는 공간을 Buffer라고 합니다.  

	BufferedReader는 문자 단위 읽기 작업을 모아서 처리하기 위한 클래스  
	PrintWriter가 문자 단위 쓰기 작업을 모아서 처리하기 위한 클래스  
	BufferedInputStream과 PrintStream을 이용해서 모아서 바이트 단위로 입출력을 할 수 있습니다.  
	우리가 사용하는 PrintStream의 대표적인 인스턴스가 System.out  
	System.out.print와 Systme.out.println과 System.out.printf의 차이  
	printf는 포맷을 설정해서 문자열을 출력, print는 모아서 출력, println은 바로 출력하고 줄 바꿈을 하는 것입니다.  
		ex ) document.writeln("<a href"); document.writeln(">"); // 안합쳐져서 오류

	버퍼의 내용은 바로 기록되지 않습니다.  
	버퍼의 내용을 내보내는 동작을 flush라고 합니다.  
	PrintWriter를 이용해서 print를 하고 나면 flush를 호출해야 합니다.  

	버퍼를 사용하는 다른 하나의 클래스로는 Scanner가 있습니다.
	Scanner sc = new Scanner(System.in);
	int x = sc.nextInt();
	int y = sc.nextInt();

* String과 StringBuilder의 차이  
	String은 변경하지 못하는 문자열을 참조하는 클래스이고, StringBuilder는 변경할 수 있는 문자열을 참조, 문자열을 추가하는 연산을 할 때는 String을 이용하게 되면 메모리낭비(Leak)이 발생할 수 있습니다. 상수는 static한 영역에 저장되서 애플리케이션이 종료될 때까지 소멸되지 않습니다.  

	String str = "Hello";
	str = str + "World";
	System.out.println(str);

	메모리 : Stack(함수가 사용하는 영역 - 일시적으로 함수가 호출되면 만들어졌다가 함수의 수행이 종료되거나 return을 만나면 소멸)  

	Heap  
		- 인스턴스가 사용하는 영역 : 인스턴스가 사용하는 영역 - 가리키는 인스턴스가 없으면 소멸(Garbage Collection이 수행)  
		- static 영역 : 상수들이 저장되는 영역으로 한번 만들어지면 애플리케이션이 종료될 때까지 유지  
	
								Hello  
	str ------------------->	HelloWorld  

	StringBuilder를 데이터를 추가할 수 있도록 여분의 공간을 가지고 인스턴스 영역에 생성됩니다.  
	String에 비해서 메모리 누수가 발생할 가능성이 적지만 연산 작업을 하지 않으면 메모리 낭비 발생  

	StringBuilder sb = new StringBuilder("Hello");  
	sb.append("World");

	sb ---------------> HelloWorld  

	JDK 1.7에서는 내부적으로 String이 StringBuilder와 유사하게 동작하기 때문에 최근에는 String을 사용하기도 하는데 면접관들은 이전에 JDK를 공부했고, 최근까지도 전자정부 프레임워크에서는 1.6버전을 사용하기 때문에 중요합니다.  

* Postman에서 http://자기컴퓨터ip:포트번호/item/list?page=1?size=15로 보냈을 때, json형식으로 데이터 나옴  

* webserver에서 전송하는 파라미터에 \가 안되므로 윈도우즈 서버를 만드는 경우 파라미터에 \안들어가도록 조심  
	C <-> Unit <-> 분산처리 ----> Web  

* 윈도우즈를 사용하는 경우 서버 애플리케이션에서 데이터페이스에 file의 저장 경로를 만들 때 UUID 대신에 /를 사용하도록 서버 수정  
	위와 같은 이유로 데이터베이스에 저장되는 것은 상관없지만 \를 프로그램에서 사용하기 위해서 호출했을 때는 제어문자로 인식할 수 있고 URL의 파라미터로 사용하는 경우에는 사용할 수 없는 문자라는 에러 메시지가 출력됩니다.  
	우리의 경우 파일을 다운로드 받는 부분에서 파일의 경로를 파라미터로 넘겨주는데 이 때 \가 있어서 문제가 발생함  

	최근에는 크게 문제가 되지 않습니다.  

	이러한 문제들이 개발 환경 과 운영 환경이 달라서 발생하는 문제였습니다.  
	운영은 대부분은 Linux 나 Unix에서 하기 때문에 이러한 문제가 발생하지 않는데 개발을 할 때 Windows를 사용함으로써 발생하는 문제였는데 최근에는 이러한 문제를 해결하기 위해서 운영 환경 과 개발 환경을 맞추는 방식으로 개발을 수행하는데 이렇게 하기 위해서 클라우드 환경에서 개발을 하거나 가상 환경(Docker 나 VMWare 등의 소프트웨어를 이용)을 만들어서 개발을 합니다.  

	이러한 가상 환경을 만들어서 이미지만 복사해서 다른 곳에 가져가면 동일한 환경에서 개발을 할 수 있습니다.  

### 4) 하단으로 스크롤했을 때 다음 페이지의 데이터 가져오기  
* MainActivity.java파일에 스크롤을 확인하기 위한 속성을 추가  
```java
// 가장하단에서 스크롤했는지 여부를 저장하기 위한 변수
private Boolean lastitemVisibleFlag = false;
```  

* MainActivity.java 파일의 onCreate 메서드 안에 ListView의 스크롤 이벤트 처리 코드를 추가  
```java
       listView.setOnScrollListener(new AbsListView.OnScrollListener(){

            @Override
            //i는 현재 스크롤 상태
            public void onScrollStateChanged(AbsListView absListView, int i) {
                //현재 스크롤이 멈춰있고 마지막에서 스크롤 했다면
                if(i == AbsListView.OnScrollListener.SCROLL_STATE_IDLE &&
                lastitemVisibleFlag){

                    //다음 페이지의 데이터 가져오기
                    //page 번호를 1증가시켜서 다음 페이지의 데이터를 요청
                    if(page >= totalPage){
                        Toast.makeText(MainActivity.this,
                                "더 이상의 데이터가 없습니다.", Toast.LENGTH_LONG).show();
                    }else{
                        page = page + 1;
                        downloadview.setVisibility(View.VISIBLE);

                        new Thread(){
                            public void run(){
                                try {
                                    //데이터 다운로드

                                    //다운로드 받을 URL을 생성
                                    //전송 방식은 GET
                                    //파라미터를 URL 뒤에 ? 하고 붙여 넣을 수 있음
                                    //파라미터는 반드시 UTF-8로 인코딩 되어야 합니다.
                                    //파라미터에 숫자 난 영문자를 제외한 부분이  있으면 인코딩 해주어야 합니다.
                                    //URLEncoder.encode("인코딩할 문자열", "utf-8")
                                    java.net.URL url = new java.net.URL(
                                            "http://192.168.10.8:9000/item/list?page=" + page
                                                    + "&size=" + size);
                                    //연결 객체 생성
                                    HttpURLConnection con = (HttpURLConnection) url.openConnection();

                                    //옵션 설정
                                    //전송 방식 설정
                                    con.setRequestMethod("GET");
                                    con.setConnectTimeout(30000);
                                    con.setUseCaches(false);

                                    //문자열을 다운로드 받기 위한 스트림을 생성
                                    BufferedReader br = new BufferedReader(
                                            new InputStreamReader(con.getInputStream()));
                                    //다운로드 받은 문자열을 저장하기 위한 객체를 생성
                                    StringBuilder sb = new StringBuilder();

                                    //다운로드 시작
                                    while(true){
                                        //한 줄 가져오기
                                        String line = br.readLine();
                                        //읽어온 데이터가 없다면 중지
                                        if(line == null){
                                            break;
                                        }
                                        //읽은 데이터를 StringBuilder에 추가
                                        sb.append(line + "\n");
                                    }

                                    //연결 객체 정리
                                    br.close();
                                    con.disconnect();
                                    Log.e("다운로드 받은 문자열", sb.toString());
                                    //다운로드 받은 데이터를 파싱
                                    //파싱한 데이터를 로컬 데이터베이스 저장
                                    if(sb.toString().trim().length() > 0){
                                        //문자열을 전체를 객체로 변환
                                        JSONObject object = new JSONObject(sb.toString());
                                        //error 값 가져오기
                                        String error = object.getString("error");
                                        //에러가 없다면
                                        if(error.equals("null")){
                                            JSONArray ar = object.getJSONArray("itemList");

                                            //데이터베이스에 대한 참조
                                            SQLiteDatabase db = itemDB.getWritableDatabase();

                                            //배열 순회
                                            for(int i=0; i<ar.length(); i++){
                                                JSONObject obj = ar.getJSONObject(i);

                                                ContentValues row = new ContentValues();
                                                Item item = new Item();

                                                row.put("itemid", obj.getLong("itemid"));
                                                item.setItemid(obj.getLong("itemid"));

                                                row.put("itemname", obj.getString("itemname"));
                                                item.setItemname(obj.getString("itemname"));

                                                row.put("price", obj.getInt("price"));
                                                item.setPrice(obj.getInt("price"));

                                                row.put("description", obj.getString("description"));
                                                item.setDescription(obj.getString("description"));

                                                row.put("pictureurl", obj.getString("pictureurl"));
                                                item.setPictureurl(obj.getString("pictureurl"));

                                                row.put("email", obj.getString("email"));
                                                item.setEmail(obj.getString("email"));

                                                db.insert("item", null, row);
                                                list.add(item);
                                            }
                                            //다시 출력해달라고 요청
                                            //데이터베이스에서 데이터를 다시 읽어서 재출력해도 되고
                                            //현재 list에 새로 추가된 데이터만 추가해도 됩니다.

                                            handler.sendEmptyMessage(0);
                                        }
                                    }



                                }catch(Exception e){
                                    Log.e("데이터 가져오기 예외", e.getLocalizedMessage());
                                }
                            }
                        }.start();

                    }

                }
            }

            @Override
            //i 는 처음에 보여지는 데이터의 인덱스
            //i1은 한 페이지에 보여지는 데이터 개수
            //i2 는 출력되어야 하는 전체 데이터 개수
            public void onScroll(AbsListView absListView, int i, int i1, int i2) {
                //마지막 부분에서 스크롤했는지 여부를 설정
                lastitemVisibleFlag = i2 > 0 && i + i1 >= i2;
            }
        });
```  

### 5) PullToRefresh(상단에서 하단으로 드래그) 구현 - 주로 새로 고침 작업을 수행합니다.  
* build.gradle 파일에 SwipeRefreshLayout을 한 의존성 추가  
```gradle
implementation 'androidx.swiperefreshlayout:swiperefreshlayout:1.1.0'
```  

* activity_main.xml 파일의 뷰 디자인을 수정  
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity"
    android:orientation="vertical">

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="ITEM LIST"
        android:textSize="32sp"
        android:gravity="center"
        android:background="@color/teal_200" />

    <ProgressBar
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:id="@+id/downloadview"/>

    <androidx.swiperefreshlayout.widget.SwipeRefreshLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:id="@+id/swipe_layout">
        
    <ListView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:id="@+id/listview"/>
        
    </androidx.swiperefreshlayout.widget.SwipeRefreshLayout>
</LinearLayout>
```  

* MainActivity.java 파일의 onCreate 메서드에 SwipeRefreshLayout의 이벤트 처리 코드 추가  
```java
     //뷰 찾아오기
        SwipeRefreshLayout swipeRefreshLayout =
                (SwipeRefreshLayout) findViewById(R.id.swipe_layout);
        //스와이프 리프레시 레이아웃에서 아래로 드래그 했을 때 수행되는 이벤트 처리
        swipeRefreshLayout.setOnRefreshListener(new SwipeRefreshLayout.OnRefreshListener() {
            @Override
            public void onRefresh() {
                downloadview.setVisibility(View.GONE);
                swipeRefreshLayout.setRefreshing(false);
                page = 1;
                new DataDisplayThread().start();
            }
        });
```  

### 6) 상세보기 구현 - ListView에서 항목을 클릭하면 새로운 화면에 데이터를 자세히 출력  
* 상세보기에 사용할 Activity 추가 - DetailActivity  

* MainActivity.java 파일의 onCreate 메서드에서 ListView의 항목을 클릭했을 때의 이벤트 처리 코드를 작성  
```java
        //ListView의 항목을 클릭했을 때 처리
        listView.setOnItemClickListener(new AdapterView.OnItemClickListener(){
            @Override
            //parent 가 listView
            //view는 누른 항목의 뷰
            //position은 인덱스
            //id는 항목 뷰의 id
            public void onItemClick(AdapterView<?>parent, View view,
                                    int position, long id){
                //다른 Activity 출력
                Intent intent = new Intent(MainActivity.this, DetailActivity.class);

                //넘겨줄 데이터 찾아오기
                Item item = list.get(position);
                //intent에 데이터 넘기기
                intent.putExtra("item", item);

                startActivity(intent);
            }
        });
```  

* activity_detail.xml 파일에서 디자인을 수정  
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".DetailActivity"
    android:orientation="vertical">

    <Button
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="뒤로"
        android:textSize="32dp"
        android:gravity="center_horizontal"
        android:id="@+id/back" />
    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:textSize="32dp"
        android:layout_gravity="center_horizontal"
        android:id="@+id/itemname"/>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal">
        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="2"
            android:textSize="24dp"
            android:text="가격"/>
        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="3"
            android:textSize="24dp"
            android:id="@+id/price"/>
    </LinearLayout>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal">
        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="2"
            android:textSize="24dp"
            android:text="설명"/>
        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="3"
            android:textSize="24dp"
            android:id="@+id/description"/>
    </LinearLayout>

    <ImageView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:id="@+id/picture"/>
</LinearLayout>
```  

* DetailActivity.java 파일의 클래스에 필요한 속성 선언  
```java
    //화면에 보여지는 뷰에 대한 속성
    private Button back;
    private TextView itemname, price, description;
    private ImageView picture;

    //이미지를 다운로드 받을 url
    private String pictureurl;
```  

* DetailActivity.java 파일에 다운로드 받은 Bitmap을 전달받아서 ImageView에 출력하는 핸들러  
```java
   //이미지 뷰에 이미지를 출력하기 위한 핸들러
    Handler handler = new Handler(Looper.getMainLooper()){
        @Override
        public void handleMessage(Message message){
            //전송된 데이터를 가져옵니다.
            Bitmap bitmap = (Bitmap)message.obj;
            //이미지 뷰에 출력
            picture.setImageBitmap(bitmap);
        }
    };
```  

* DetailActivity.java 파일에 pictureurl 값을 가지고 이미지를 다운로드 받는 스레드를 생성  
```java
    //이미지를 다운로드 받기 위한 스레드
    class ThreadEx extends Thread{
        public void run(){
            try {
                URL url = new URL("http://192.168.10.8:9000/member/download?path=" + pictureurl);
                //파일을 다운로드 받기 위한 스트림 생성
                InputStream inputStream = url.openStream();
                
                //안드로이드에서 이미지인 경우만 가능
                Bitmap bit = BitmapFactory.decodeStream(inputStream);
                
                //핸들러에게 bit를 전송해서 picture에서 출력하도록 합니다.
                Message message = new Message();
                message.obj = bit;
                handler.sendMessage(message);
                
            }catch(Exception e){
                Log.e("이미지 다운로드 실패", e.getLocalizedMessage());
            }
        }
    }
```  

* DetailActivity.java 파일의 onCreate 메서드에 뷰를 출력하는 코드를 작성  
```java
       //뷰를 찾아오기
        back = (Button)findViewById(R.id.back);
        itemname = (TextView)findViewById(R.id.itemname);
        price = (TextView)findViewById(R.id.price);
        description = (TextView)findViewById(R.id.description);
        picture = (ImageView)findViewById(R.id.picture);

        //이전 Activity로부터 넘겨받은 데이터 가져오기
        Intent intent = getIntent();
        Item item = (Item)intent.getSerializableExtra("item");

        //넘어온 데이터 출력
        itemname.setText(item.getItemname());
        price.setText(item.getPrice() + "원");
        description.setText(item.getDescription());

        //이미지 파일이름 저장
        pictureurl = item.getPictureurl();
        
        //back 버튼의 클릭 이벤트
        back.setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View v){
                //현재 Activity를 종료
                finish();
            }
        });
        
        //이미지를 다운로드 받아주는 스레드를 생성하고 실행
        new ThreadEx().start();
```  

### 7) 화면 이동: 메인 화면에 버튼을 3개 만들어서 로그인(로그아웃 과 토글), 회원 가입, 아이템 삽입 화면으로 이동  

* 3개의 Activity 추가: LoginActivity, MemberRegisterActivity, ItemRegisterActivity  

* activity_main.xml 파일에 버튼을 3개 추가  
```xml
   <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal">
        <Button
            android:layout_width="0dp"
            android:layout_height="match_parent"
            android:layout_weight="1"
            android:text="로그인"
            android:id="@+id/loginbtn"/>
        <Button
            android:layout_width="0dp"
            android:layout_height="match_parent"
            android:layout_weight="1"
            android:text="회원가입"
            android:id="@+id/memberregisterbtn"/>
        <Button
            android:layout_width="0dp"
            android:layout_height="match_parent"
            android:layout_weight="1"
            android:text="아이템추가"
            android:id="@+id/itemregisterbtn"/>
        
    </LinearLayout>
```  

* MainActivity.java 클래스에 추가한 버튼 3개 와 연결할 인스턴스 변수를 선언  
```java
//버튼 3개의 속성
private Button loginbtn, memberregisterbtn, itemregisterbtn;
```  

* MainActivity.java 파일의 onCreate 메서드에서 버튼을 찾아오고 버튼의 클릭 이벤트 처리  
```java
        loginbtn = (Button)findViewById(R.id.loginbtn);
        loginbtn.setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View v){
                if(loginbtn.getText().equals("로그인")){
                    Intent intent = new Intent(
                            MainActivity.this, LoginActivity.class);
                    startActivity(intent);
                    
                }else{

                    loginbtn.setText("로그인");
                }
            }
        });

        memberregisterbtn = (Button)findViewById(R.id.memberregisterbtn);
        memberregisterbtn.setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View v){
                Intent intent = new Intent(
                        MainActivity.this, MemberRegisterActivity.class);
                startActivity(intent);
            }
        });

        itemregisterbtn = (Button)findViewById(R.id.itemregisterbtn);
        itemregisterbtn.setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View v){
                Intent intent = new Intent(
                        MainActivity.this, ItemRegisterActivity.class);
                startActivity(intent);
            }
        });
```  

### 8) 로그인 처리  
* activity_login.xml 파일을 수정해서 로그인 화면을 생성  
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".LoginActivity"
    android:orientation="vertical">
    
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:gravity="center_vertical"
        android:orientation="horizontal">
        
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text=" EMAIL:"/>
        <EditText
            android:layout_width="200dp"
            android:layout_height="wrap_content"
            android:id="@+id/emailinput"
            android:inputType="textEmailAddress"
            android:text=""/>
        
    </LinearLayout>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:gravity="center_vertical"
        android:orientation="horizontal">

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text=" PASSWORD:"/>
        <EditText
            android:layout_width="200dp"
            android:layout_height="wrap_content"
            android:id="@+id/pwinput"
            android:inputType="textPassword"
            android:text=""/>

    </LinearLayout>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:gravity="center_vertical"
        android:orientation="horizontal">

        <Button
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="로그인" 
            android:gravity="center_horizontal"
            android:id="@+id/btnlogin"/>
        <Button
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="회원가입"
            android:gravity="center_horizontal"
            android:id="@+id/btnregister"/>
      

    </LinearLayout>
</LinearLayout>
```  

* LoginActivity.java 파일에 사용할 뷰에 대한 속성을 생성
```java
    EditText emailinput, pwinput;
    Button btnlogin, btnregister;
```  

* LoginActivity.java 파일의 onCreate 메서드에 뷰에 참조를 찾아오는 코드를 추가  
```java
        emailinput = (EditText)findViewById(R.id.emailinput);
        pwinput = (EditText)findViewById(R.id.pwinput);
        btnlogin = (Button)findViewById(R.id.btnlogin);
        btnregister = (Button)findViewById(R.id.btnregister);
```  

* LoginActivity.java 파일의 onCreate 메서드에서 회원 가입 버튼을 눌렀을 때 회원 가입 화면으로 이동하도록 코드를 추가  
```java
        btnregister.setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View view) {
                //이동할 Activity를 Intent로 생성
                Intent intent = new Intent(LoginActivity.this, MemberRegisterActivity.class);
                //전송할 데이터가 있으면 데이터 설정
                //intent.putExtra("이름", 데이터);
                startActivity(intent);
            }
        });
```  

* 로그인 처리 과정:로그인 버튼을 누르면 클라이언트 유효성 검사를 수행하고 유효성 검사를 통과하면 그 데이터를 서버에 전송해서 로그인 가능 여부를 판단하고 로그인이 되면 유저에 대한 정보를 받아서 로컬 데이터베이스 나 파일 시스템에 저장  

* LoginActivity.java 파일의 onCreate 메서드에서 회원 가입 버튼을 눌렀을 때 처리하는 코드를 작성  
```java
       btnlogin.setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View view) {
                //email 과 password 읽어오기
                String email = emailinput.getText().toString().trim().toLowerCase();
                String pw = pwinput.getText().toString().trim();

                //유효성 검사

                Handler handler = new Handler(Looper.getMainLooper()){
                    public void handleMessage(Message message){
                        String error = (String)message.obj;
                        Toast.makeText(LoginActivity.this, error, Toast.LENGTH_LONG).show();
                    }
                };

                //웹 서버에게 데이터를 전송하는 스레드 생성
                new Thread(){
                    public void run(){
                        try {
                            //URL 생성
                            URL url = new URL("http://192.168.10.8:9000/member/login");

                            //연결 객체 생성
                            HttpURLConnection con = (HttpURLConnection) url.openConnection();

                            //옵션 설정
                            con.setRequestMethod("POST");
                            con.setUseCaches(false);

                            //파일업로드가 없는 POST 방식에서의 파라미터 생성(email, password)
                            String data = URLEncoder.encode("email", "UTF-8") + "="
                                    + URLEncoder.encode(email, "UTF-8")
                                    + "&" + URLEncoder.encode("password", "UTF-8") + "="
                                    + URLEncoder.encode(pw, "UTF-8");
                            //파라미터를 전송
                            OutputStreamWriter wr = new OutputStreamWriter(con.getOutputStream());
                            wr.write(data);
                            wr.flush();

                            BufferedReader br = new BufferedReader(
                                    new InputStreamReader(con.getInputStream()));
                            StringBuilder sb = new StringBuilder();
                            while(true){
                                String line = br.readLine();
                                if(line == null){
                                    break;
                                }
                                sb.append(line + "\n");
                            }
                            Log.e("받아온 문자열", sb.toString());
                            br.close();
                            con.disconnect();

                            //받아온 데이터 파싱
                            JSONObject object = new JSONObject(sb.toString());
                            String error = object.getString("error");
                            //Log.e("error", error);
                            if(error.equals("null")){
                                Log.e("결과", "로그인 성공");
                                //로그인 성공했을 때 넘어온 데이터를 읽기
                                String name = object.getString("name");
                                String imageurl = object.getString("imageurl");
                                //개인 정보를 파일에 저장 - 이 정보가 있으면 로그인을 한 것이고 없으면 로그인을 안한 것
                                FileOutputStream fos = openFileOutput(
                                        "login.txt", Context.MODE_PRIVATE);
                                String str = email + ":" + name + ":" + imageurl;
                                fos.write(str.getBytes());
                                fos.close();

                                //메인 화면으로 이동
                                Intent intent = new Intent(
                                        LoginActivity.this, MainActivity.class);
                                startActivity(intent);
                            }else{
                                Message message = new Message();
                                message.obj = error;
                                handler.sendMessage(message);
                            }



                        }catch(Exception e){
                            Log.e("로그인 시도 실패", e.getLocalizedMessage());
                        }
                    }
                }.start();
            }
        });
```  

* MainActivity.java 파일에 화면에 보여질 때 호출되는 메서드를 재정의  
```java
    //액티비티가 최상단에 보여질 때 마다 호출되는 메서드
    //onCreate 다음에 호출되는 메서드
    @Override
    public void onResume(){
        super.onResume();
        //로그인 여부를 확인해서 로그인 버튼의 텍스트를 수정
        try{
            FileInputStream fis = openFileInput("login.txt");
            byte[] data = new byte[fis.available()];
            fis.read(data);
            String loginText = new String(data);
            Log.e("로그인 정보", loginText);
            
            loginbtn.setText("로그아웃");
        }catch(Exception e){
            loginbtn.setText("로그인");
        }
    }
```  

* MainActivity.java 파일의 onCreate 메서드에서 로그인 버튼을 클릭했을 때를 수정  
```java
       loginbtn.setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View v){
                if(loginbtn.getText().equals("로그인")){
                    Intent intent = new Intent(
                            MainActivity.this, LoginActivity.class);
                    startActivity(intent);

                }else{
                    //로그인 정보가 있는 파일을 삭제
                    deleteFile("login.txt");
                    loginbtn.setText("로그인");
                }
            }
        });
```  

### 9) 아이템 추가 버튼을 눌렀을 때 로그인이 안된 상태면 로그인 화면으로 페이지로 이동하고 로그인이 된 상태되면 아이템 추가 화면으로 이동하도록 만들기
* MainActivity.java 파일의 onCreate 메서드에서 아이템 추가 버튼을 클릭했을 때 호출되는 코드를 수정  
```java
        itemregisterbtn.setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View v){
                try{
                    FileInputStream fis = openFileInput("login.txt");
                    byte[] data = new byte[fis.available()];
                    fis.read(data);

                    Intent intent = new Intent(
                            MainActivity.this, ItemRegisterActivity.class);
                    startActivity(intent);
                }catch(Exception e){
                    Intent intent = new Intent(
                            MainActivity.this, LoginActivity.class);
                    startActivity(intent);
                }

            }
        });
```  
* +) 파이썬 크롤링한다는 책 중 대부분이 예외처리 안하므로 피할 것  
    SNS에서 최근의 데이터 수집  
    몇 개의 데이터가 있는지 확인(100) -> 수집(99) 이런 예외 처리가 안됨

### 10) 회원 가입(email, password + confirmpassword, name, image, 회원가입버튼 + 다른용도버튼, 앱 내의 파일을 가져오는 버튼, 갤러리에서 가져오는 버튼, 카메라 촬영해서 가져오는 버튼) - 아이템 삽입, 회원 정보 수정, 아이템 수정 동일  
* activity_member_register.xml 파일을 수정  
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MemberRegisterActivity"
    android:orientation="vertical">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal">
        <Button
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="회원가입"
            android:id="@+id/registerbtn"/>
        <Button
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="메인화면"
            android:id="@+id/mainbtn"/>
    </LinearLayout>
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical">
        <EditText
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="이메일을 입력하세요"
            android:id="@+id/emailinput"
            android:inputType="textEmailAddress"/>
        <EditText
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="비밀번호를 입력하세요"
            android:id="@+id/pwinput"
            android:inputType="textPassword"/>
        <EditText
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="비밀번호를 입력하세요"
            android:id="@+id/pwconfirminput"
            android:inputType="textPassword"/>
        <EditText
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="별명을 입력하세요"
            android:id="@+id/nameinput"
            android:inputType="text"/>

    </LinearLayout>
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal">
        <Button
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="앱내이미지"
            android:id="@+id/localbtn"/>
        <Button
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="갤러리"
            android:id="@+id/gallerybtn"/>
        <Button
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="카메라"
            android:id="@+id/camerabtn"/>
    </LinearLayout>
    <ImageView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:id="@+id/image"/>
</LinearLayout>
```  
* 앱에 이미지를 추가 - res 디렉토리에 raw 디렉토리를 생성하고 복사(drawable 디렉토리에 해도 되는데 drawable 디렉토리에 복사면 앱을 시작할 때 메모리에 로드를 합니다.)  

* MemberRegisterActivity.java 파일에 뷰 관련 속성들을 인스턴스 변수로 생성  
```java
    private Button registerbtn, mainbtn, localbtn, gallerybtn, camerabtn;
    private EditText emailinput, pwinput, pwconfirminput, nameinput;
    private ImageView image;
```  

* MemberRegisterActivity.java 파일의 onCreate 메서드에서 뷰 관련 속성들을 찾아오기  
```java
        registerbtn = (Button)findViewById(R.id.registerbtn);
        mainbtn = (Button)findViewById(R.id.mainbtn);
        localbtn = (Button)findViewById(R.id.localbtn);
        gallerybtn = (Button)findViewById(R.id.gallerybtn);
        camerabtn = (Button)findViewById(R.id.camerabtn);

        emailinput = (EditText)findViewById(R.id.emailinput);
        pwinput = (EditText)findViewById(R.id.pwinput);
        pwconfirminput = (EditText)findViewById(R.id.pwconfirminput);
        nameinput = (EditText)findViewById(R.id.nameinput);

        image = (ImageView)findViewById(R.id.image);
```  

* MemberRegisterActivity.java 파일의 onCreate 메서드에 mainbtn의 클릭 이벤트 처리  
```java
        mainbtn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                //현재 Activity 종료
                finish();
            }
        });
```  

* MemberRegisterActivity.java 파일의 onCreate 메서드에 localbtn의 클릭 이벤트 처리  
```java
       localbtn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                //raw 디렉토리에 있는 이미지를 읽어서 ImageView에 출력
                Bitmap bitmap = BitmapFactory.decodeResource(
                        getResources(),R.raw.choi);
                image.setImageBitmap(bitmap);
            }
        });
```  

* MemberRegisterActivity.java 파일에 갤러리에서 사진을 가져올 수 있도록 갤러리를 화면에 출력한 후 호출되는 ActivityResultLauncher 인스턴스를 생성  
```java
   //갤러리 화면에서 이미지를 선택한 후 동작하는 Launcher 인스턴스
    ActivityResultLauncher<Intent> imageLauncher = 
            registerForActivityResult(
                    new ActivityResultContracts.StartActivityForResult(),
                    new ActivityResultCallback<ActivityResult>() {
                        @Override
                        public void onActivityResult(ActivityResult result) {
                            if(result.getResultCode() == RESULT_OK){
                                Intent intent = result.getData();
                                Uri uri = intent.getData();
                                image.setImageURI(uri);
                            }
                        }
                    });
```  

* MemberRegisterActivity.java 파일의 onCreate 메서드에 gallerybtn의 클릭 이벤트 처리  
```java
        gallerybtn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                Intent intent = new Intent();
                intent.setType("image/*");
                intent.setAction(Intent.ACTION_GET_CONTENT);
                imageLauncher.launch(intent);
            }
        });
```  

* 카메라 사용을 위해서 권한을 추가 - AndroidManifest.xml 파일에 추가  
```xml
     <!-- 카메라 권한 추가 -->
    <uses-feature android:name="android.hardware.camera"
        android:required="true"/>
```  

* 카메라 화면이 종료된 후 작업을 수행할 Launcher 인스턴스를 MemberRegisterActivity.java 파일에 생성  
```java
    //카메라 화면에서 이미지를 선택한 후 동작하는 Launcher 인스턴스
    ActivityResultLauncher<Intent> cameraLauncher =
            registerForActivityResult(
                    new ActivityResultContracts.StartActivityForResult(),
                    new ActivityResultCallback<ActivityResult>() {
                        @Override
                        public void onActivityResult(ActivityResult result) {
                            if(result.getResultCode() == RESULT_OK){
                                Intent intent = result.getData();
                                Bundle extras = intent.getExtras();
                                Bitmap bitmap = (Bitmap)extras.get("data");
                                image.setImageBitmap(bitmap);
                            }
                        }
                    });
```  

* MemberRegisterActivity.java파일의 onCreate메서드에 camerabtn의 클릭이벤트 처리  
```java
camerabtn = (Button)findViewById(R.id.camerabtn);
        camerabtn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
                cameraLauncher.launch(intent);
            }
        });
```  

* +) Layout중에는 겹쳐서 출력할 수 있는 레이아웃이 있습니다.  
카메라 화면을 FramLayout위에 올려놓고 그 위에 이미지를 출력할 수 있습니다.  

지도 위에 동일한 작업을 할 수 있습니다.  

증강 현실  
- 카메라 기반의 증강현실  
- 위치 기반의 증강현실  

* MemberRegisterActivcity.java 파일의 onCreate 메서드에 회원 가입 버튼의 클릭 이벤트 처리  
```java
        registerbtn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                Handler handler = new Handler(Looper.getMainLooper()){
                  @Override
                  public void handleMessage(Message message){
                      String msg = (String)message.obj;
                      Toast.makeText(MemberRegisterActivity.this, msg, Toast.LENGTH_LONG).show();
                  }
                };

                //입력한 내용을 전부 읽어옵니다.
                //getText()의 결과는 Editable 타입이라서 문자열로 바로 사용할 수 없어서
                //인스턴스를 문자열로 치환해주는 toString()을 호출해서 문자열로 변환합니다.
                String email = emailinput.getText().toString().trim();
                String pw = pwinput.getText().toString();
                String pwconfirm = pwconfirminput.getText().toString();
                String name = nameinput.getText().toString();

                Message message = new Message();
                //입력한 내용이 없는 경우
                if(email.length() == 0){
                    message.obj = "이메일은 필수 입력입니다.";
                    handler.sendMessage(message);
                    return;
                }else{
                    //email 정규식 객체 생성
                    String regex = "^[_a-z0-9-]+(.[_a-z0-9-]+)*@(?:\\w+\\.)+\\w+$";
                    Pattern p = Pattern.compile(regex);
                    //email 을 정규식 객체의 패턴에 맞는지 확인
                    Matcher m = p.matcher(email);
                    //정규식 패턴에 맞지 않는다면 에러
                    if(m.matches() == false){
                        message.obj = "이메일 형식에 맞지 않습니다.";
                        handler.sendMessage(message);
                        return;
                    }
                }

                //비밀번호 관련 유효성 검사
                if(pw.length() == 0){
                    message.obj = "비밀번호는 필수 입력입니다.";
                    handler.sendMessage(message);
                    return;
                }else{
                    //password 정규식 객체 생성
                    //영문 대소문자 숫자 특수문자 포함 8자 이상
                    String regex = "^(?=.*[a-z])(?=.*[A-Z])(?=.*[$@$!%*?&])[A-Za-z\\d$@$!%*?&]{8,}";
                    Pattern p = Pattern.compile(regex);
                    //pw가 정규식 객체의 패턴에 맞는지 확인
                    Matcher m = p.matcher(pw);
                    if(m.matches() == false){
                        message.obj = "비밀번호는 영문 대소문자 와 숫자 및 특수문자를 포함해야 합니다.";
                        handler.sendMessage(message);
                        return;
                    }
                }

                if(pw.equals(pwconfirm) == false){
                    message.obj = "2개의 비밀번호가 다릅니다.";
                    handler.sendMessage(message);
                    return;
                }

                if(name.length() < 2){
                    message.obj = "이름은 2자 이상이어야 합니다.";
                    handler.sendMessage(message);
                    return;
                }else{
                    String regex = "[0-9]|[a-z]|[A-Z]|[가-힣]";
                    for(int i=0; i<name.length(); i++) {
                        String ch = name.charAt(i) + "";
                        Pattern p = Pattern.compile(regex);
                        //pw가 정규식 객체의 패턴에 맞는지 확인
                        Matcher m = p.matcher(ch);
                        if(m.matches() == false){
                            message.obj = "별명에는 영문 과 숫자 그리고 한글만 사용해야 합니다..";
                            handler.sendMessage(message);
                            return;
                        }
                    }
                }

                //서버에 요청을 전송할 스레드 생성
                new Thread(){
                    @Override
                    public void run(){
                        try{
                            //회원 가입을 위한 서버 URL
                            URL url = new URL("http://192.168.10.8:9000/member/register");

                            //연결 객체를 생성
                            HttpURLConnection con = (HttpURLConnection)url.openConnection();
                            con.setRequestMethod("POST");
                            con.setConnectTimeout(30000);
                            con.setUseCaches(false);

                            //파일을 제외한 파라미터 만들기
                            String [] data = {email, pw, name};
                            String [] dataName = {"email", "password", "name"};

                            //boundary 생성 - 실행할 때 마다 다른 값을 같도록 해주어야 함
                            String boundary = UUID.randomUUID().toString();
                            //라인의 종료를 위한 변수
                            String lineEnd = "\r\n";

                            //파일 첨부가 있는 경우 설정
                            //html에서도 form 안에 file 이 있는 경우는 반드시 enctype을 multipart/form-data로 전송해야 ㅎ바니다.
                            con.setRequestProperty("ENCTYPE", "multipart/form-data");
                            con.setRequestProperty(
                                    "Content-Type", "multipart/form-data;boundary=" + boundary);

                            //파라미터 구분자 생성
                            String delimiter = "--" + boundary + lineEnd;

                            //파라미터를 하나로 묶기
                            StringBuffer postDatabuilder = new StringBuffer();
                            for(int i=0; i<data.length; i++){
                                postDatabuilder.append(delimiter);
                                postDatabuilder.append("Content-Disposition: form-data; name=\"" +
                                        dataName[i] + "\"" + lineEnd + lineEnd + data[i] + lineEnd);
                            }

                            //파일 파라미터 생성
                            String fileName = name + ".png";
                            //이미지 뷰에 이미지가 출력된 경우에만
                            if(image.getDrawable() != null){
                                postDatabuilder.append(delimiter);
                                postDatabuilder.append("Content-Disposition: form-data; name=\"" +
                                        "image" + "\";filename=\"" + fileName + "\"" + lineEnd);
                            }

                            //파라미터 전송
                            DataOutputStream ds = new DataOutputStream(con.getOutputStream());
                            ds.write(postDatabuilder.toString().getBytes());
                            //이미지 업로드
                            if(image.getDrawable() != null){
                                ds.writeBytes(lineEnd);

                                //raw 디렉토리에 존재하는 이미지인 경우
                                //InputStream fres = getResources().openRawResource(R.raw.choi);

                                //ImageView의 내용을 가지고 스트림 생성
                                BitmapDrawable drawable = (BitmapDrawable) image.getDrawable();
                                Bitmap bitmap = drawable.getBitmap();

                                ByteArrayOutputStream baos = new ByteArrayOutputStream();
                                bitmap.compress(Bitmap.CompressFormat.PNG, 100, baos);
                                InputStream fres = new ByteArrayInputStream(baos.toByteArray());

                                //이미지 업로드
                                byte [] buffer = new byte[fres.available()];

                                int length = -1;
                                while((length = fres.read(buffer)) != -1){
                                    ds.write(buffer, 0, length);
                                }
                                ds.writeBytes(lineEnd);
                                ds.writeBytes(lineEnd);
                                ds.writeBytes("--" + boundary + "--" + lineEnd);
                                fres.close();
                            }else{
                                ds.writeBytes(lineEnd);
                                ds.writeBytes("--" + boundary + "--" + lineEnd);
                            }
                            ds.flush();
                            ds.close();

                            //API Server에게 전송하고 문자열 응답을 받기 위한 준비
                            BufferedReader br = new BufferedReader(
                                    new InputStreamReader(con.getInputStream()));
                            StringBuilder sb = new StringBuilder();

                            while(true){
                                String line = br.readLine();
                                if(line == null){
                                    break;
                                }
                                sb.append(line + "\n");
                            }

                            br.close();
                            con.disconnect();

                            if(sb.toString().length() >= 1){
                                //받아온 문자열을 JSON 객체로 변환
                                JSONObject object = new JSONObject(sb.toString());
                                //JSON 객체에서 email 키에 해당하는 값을 문자열로 저장
                                String result = object.getString("email");
                                if(email.equals(result)){
                                    //회원 가입 성공
                                    finish();

                                }else{
                                    //회원 가입 실패
                                    message.obj = email;
                                    handler.sendMessage(message);
                                }
                            }
                        }catch(Exception e){
                            message.obj = e.getLocalizedMessage();
                            handler.sendMessage(message);
                        }
                    }
                }.start();
            }
        });
```  

## 12. 위치 정보 사용  
* 안드로이드에서 로그인에 성공하면 위치 정보를 서버로 전송하면 서버는 그 위치 정보를 가지고 주소로 변환해서 데이터베이스에 저장하기  

### 1)안드로이드에서 테스트  
* 준비사항  
  위치 정보는 동적 권한(사용을 할 때 권한 요청) 설정을 요구: AutoPermissions 라이브러리로 해결  
  FINE_LOCATION 과 ACCESS_COARSE_LOCATION 권한이 필요  

* 테스트를 위해서 실행 가능한 Activity를 추가 - LocationActivity  
    Activity를 생성할 때 Launcher Activity를 체크  

* 동적 권한 설정을 위한 외부 라이브러리(AutoPermissions)의 의존성을 설정: 최근에 Repository 설정 부분이 변경되었으므로 주의  
    - settings.gradle 파일에 저장소 추가  
```gradle
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
        maven{url 'https://jitpack.io'}
    }
}
```  

    - module 수준의 build.gradle 파일에 의존성 라이브러리를 설정  
```gradle
implementation 'com.github.pedroSG94:AutoPermissions:1.0.3'
```  

    - gradle.properties 파일에 추가  
```ini
android.enableJetifier=true
```  

* activity_location.xml 파일에 디자인을 수정  
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".LocationActivity"
    android:orientation="vertical">

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="현재 위치"
        android:id="@+id/textView"
        />
    <Button
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="위치 정보 확인"
        android:id="@+id/button"/>
</LinearLayout>
```  

* AndroidManifest.xml 파일에 위치 정보 사용을 위한 권한을 설정  
```xml
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/>
```  

* LocationActivity 클래스에 AutoPermissionsListener를 implements  
```java
public class LocationActivity extends AppCompatActivity implements AutoPermissionsListener
```  

* LocationActivity 클래스에 TextView 와 Button에 대한 참조를 저장할 속성을 생성  
```java
    TextView textView;
    Button button;
```  

* LocationActivity 클래스의 onCreate 메서드에 TextView 와 Button에 대한 참조를 저장하는 코드를 작성  
```java
    textView = (TextView)findViewById(R.id.textView);
    button = (Button)findViewById(R.id.button);
```  

* 동적 권한 설정을 위한 코드 작성  
    - LocationActivity 클래스의 onCreate 메서드에 필요한 동적 권한을 요청하는 메서드를 호출하는 코드를 작성  
```java
        //동적 권한 요청
        AutoPermissions.Companion.loadAllPermissions(this, 101);
```  

    - LocationActivity 클래스에 onDenied 메서드 재정의  
```java
   @Override
    public void onDenied(int i, String[] strings) {
        Toast.makeText(this, "거부한 권한 개수:" + strings.length,
                Toast.LENGTH_LONG).show();
    }
```  

    - LocationActivity 클래스에 onGranted 메서드 재정의  
```java
    //권한 사용을 허용한 경우에 그 개수를 파악해주는 메서드
    @Override
    public void onGranted(int i, String[] strings) {
        Toast.makeText(this, "허용한 권한 개수:" + strings.length,
                Toast.LENGTH_LONG).show();
    }
```  

    - LocationActivity 클래스에 퍼미션 설정을 하고 나면 호출되는 메서드를 재정의  
```java
    @Override
    public void onRequestPermissionsResult(int requestCode, 
                                            String permissions[],
                                            int [] grantResults) {
        super.onRequestPermissionsResult(
                requestCode, permissions, grantResults);
        
        AutoPermissions.Companion.parsePermissions(this, requestCode,
                permissions, this);
    }
```  

* LocationActivity 클래스에 위치 정보를 요청하거나 변경하는 경우 작업을 수행할 Listener 클래스를 생성  
```java
    class GPSListener implements LocationListener{

        //위치 정보를 처음 받거나 갱신된 경우 호출되는 메서드
        @Override
        public void onLocationChanged(@NonNull Location location) {
            //위도와 경도 가져오기
            Double latitude = location.getLatitude();
            Double longitude = location.getLongitude();
            
            String message = "내 위치\n Latitude:" + latitude + 
                    "\nLongitude:" + longitude;
            textView.setText(message);
        }

        @Override
        public void onStatusChanged(String provider, int status, Bundle extras) {
            LocationListener.super.onStatusChanged(provider, status, extras);
        }

        @Override
        public void onProviderEnabled(@NonNull String provider) {
            LocationListener.super.onProviderEnabled(provider);
        }

        @Override
        public void onProviderDisabled(@NonNull String provider) {
            LocationListener.super.onProviderDisabled(provider);
        }
    }
```  

* LocationActivity 클래스의 onCreate 메서드에 버튼을 눌렀을 때 수행할 코드를 작성  
```java
       button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                //위치 정보 서비스를 위한 객체를 생성
                LocationManager manager =
                        (LocationManager) getSystemService(Context.LOCATION_SERVICE);
                try{
                    //이전 위치를 출력
                    Location location = manager.getLastKnownLocation(LocationManager.GPS_PROVIDER);
                    if(location != null){
                        double latitude = location.getLatitude();
                        double longitude = location.getLongitude();
                        String message = "최근 위치\n Latitude:" + latitude +
                                "\nLongitude:" + longitude;
                        textView.setText(message);
                    }

                    //리스너 객체 생성
                    GPSListener gpsListener = new GPSListener();
                    //옵션 설정 - 10초마다 위치 정보를 갱신하고 최소 이동거리를 설정
                    long minTime = 10000;
                    float minDistance = 0;

                    manager.requestLocationUpdates(
                            LocationManager.GPS_PROVIDER, minTime, minDistance, gpsListener);
                    Toast.makeText(LocationActivity.this, "위치 정보 확인 요청",
                            Toast.LENGTH_LONG).show();
                }catch(SecurityException e){
                    Toast.makeText(LocationActivity.this, e.getLocalizedMessage(),
                            Toast.LENGTH_LONG).show();
                }

            }
        });
```  

### 2) 데이터베이스에 테이블을 생성  
* 로그인 한 email 과 주소 그리 날짜를 저장할 수 있는 테이블을 생성  
```sql
create table login_info(
	logininfoid INTEGER PRIMARY KEY AUTO_INCREMENT,
	email VARCHAR(255) NOT NULL,
	address VARCHAR(1000),
	regdate DATETIME(6)
);
```  

### 3) 카카오 오픈 API를 사용하기 위한 설정  
* developer.kakao.com에 접속해서 로그인  

* 기존 애플리케이션이 있으면 재활용하고 없으면 애플리케이션 생성

### 4) Spring Boot Server 작업  
* json 파싱을 위한 라이브러리의 의존성을 설정: build.gradle 파일의 dependecies에 추가  
```gralde
implementation group:'org.json', name:'json', version:'20220320'
```  

* login_info 와 연동할 Entity 추가: LoginInfo  
```java
@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
@Entity
public class LoginInfo {
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long logininfoid;
	private String email;
	private String address;
	private LocalDateTime regdate;
}
```  

* LoginInfo 작업을 위한 Repository 인터페이스 생성  
```java
public interface LoginInfoRepository extends JpaRepository<LoginInfo, Long>{

}
```  

* LoginInfo 요청을 받을 DTO 클래스 생성 - LoginInfoDTO  
```java
@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginInfoDTO {
		private Long logininfoid;
		private String email;
		private Double longitude;
		private Double latitude;
		private String address;
		private LocalDateTime regdate;
}
```  

* LoginInfo 요청을 처리하기 위한 메서드를 선언할 Service 인터페이스 생성 - LoginInfoService  
```java
public interface LoginInfoService {
	//데이터 삽입을 위한 메서드
	public Long registerLoginInfo(LoginInfoDTO dto);
	
	//LoginInfoDTO를 LoginInfo로 변환해주는 메서드 
	public default LoginInfo dtoToEntity(LoginInfoDTO dto) {
		LoginInfo loginInfo = LoginInfo.builder()
				.email(dto.getEmail())
				.address(dto.getAddress())
				.regdate(dto.getRegdate())
				.build();
		
		return loginInfo;
	}
}
```  

* LoginInfo 요청을 처리할 메서드를 구현할 Service 클래스를 생성 - LoginInfoServiceImpl  
```java
@Service
@RequiredArgsConstructor
public class LoginInfoServiceImpl implements LoginInfoService {
	private final LoginInfoRepository loginInfoRepository;
	
	@Override
	public Long registerLoginInfo(LoginInfoDTO dto) {
		//현재 날짜 및 시간을 설정
		dto.setRegdate(LocalDateTime.now());
		
		//위도와 경도 가져오기
		Double longitude = dto.getLongitude();
		Double latitude = dto.getLatitude();
		
		System.out.println("Service:" + dto);
		//위도 와 경도가 전송된 경우에만 작업을 수행
		if(longitude != null && latitude != null) {
			try {
				//전송받을 URL 생성
				URL url = new URL("https://dapi.kakao.com/v2/local/geo/coord2address.json?" + 
				"x=" + longitude + "&y=" + latitude + "&input_coord=WGS84");
				
				HttpURLConnection con = (HttpURLConnection)url.openConnection();
				con.setConnectTimeout(30000);
				con.setUseCaches(false);
				//헤더 설정 - 최근의 Open API는 아이디 와 비밀번호 대신에 
				//API Key를 이용해서 인증을 받습니다.
				con.setRequestProperty(
						"Authorization","KakaoAK 22a3921506dda23553e01dfcb1a67896");
				
				BufferedReader br = new BufferedReader(
						new InputStreamReader(con.getInputStream()));
				StringBuilder sb = new StringBuilder();
				while(true) {
					String line = br.readLine();
					if(line == null) {
						break;
					}
					sb.append(line + "\n");
				}
				br.close();
				con.disconnect();
				System.out.println("카카오에서 받은 데이터:" + sb.toString());
				
				if(sb.toString().length() > 0) {
					JSONObject object = new JSONObject(sb.toString());
					//검색된 데이터 개수 가져오기
					JSONObject meta = object.getJSONObject("meta");
					Integer total_count = meta.getInt("total_count");
					if(total_count > 0) {
						JSONArray documents = object.getJSONArray("documents");
						//첫번째 데이터 가져오기
						JSONObject first = documents.getJSONObject(0);
						try {
							JSONObject road_address = first.getJSONObject("road_address");
							String address_name = road_address.getString("address_name");
							System.out.println("주소:" + address_name);
							//주소 설정
							dto.setAddress(address_name);
						}catch(Exception e) {
							JSONObject address = first.getJSONObject("address");
							String address_name = address.getString("address_name");
							System.out.println("주소:" + address_name);
							//주소 설정
							dto.setAddress(address_name);
						}
					}
							
				}
			}catch(Exception e) {
				System.out.println("데이터 가져오기 에러" + e.getLocalizedMessage());
			}
		}
		//데이터 변환 후 삽입
		LoginInfo loginInfo = dtoToEntity(dto);
		loginInfoRepository.save(loginInfo);
		return loginInfo.getLogininfoid();
	}

}
```  

* LoginInfo 요청 처리를 위한 Controller 클래스를 생성하고 작성 - LoginInfoController  
```java
@RestController
@RequestMapping("logininfo")
@RequiredArgsConstructor
public class LoginInfoController {
	private final LoginInfoService loginInfoService;
	
	@GetMapping("/location")
	public ResponseEntity<?> setLoginInfo(LoginInfoDTO dto){
		String response = null;
		loginInfoService.registerLoginInfo(dto);
		response ="성공";
		return ResponseEntity.ok().body(response);
		
	}
}
```  

### 5) Android 처리  
* LoginActivity 클래스의 선언부 변경  
```java
public class LoginActivity extends AppCompatActivity implements AutoPermissionsListener
```  

* LoginActivity 클래스에 속성 선언  
```java
Double latitude, longitude;
```  

* LoginActivity 클래스에 권한 요청 과 관련된 메서드 재정의  
```java
    //권한 사용을 거부한 경우에 그 개수를 파악해주는 메서드
    @Override
    public void onDenied(int i, String[] strings) {
        Toast.makeText(this, "거부한 권한 개수:" + strings.length,
                Toast.LENGTH_LONG).show();
    }

    //권한 사용을 허용한 경우에 그 개수를 파악해주는 메서드
    @Override
    public void onGranted(int i, String[] strings) {
        Toast.makeText(this, "허용한 권한 개수:" + strings.length,
                Toast.LENGTH_LONG).show();
    }

    @Override
    public void onRequestPermissionsResult(int requestCode,
                                           String permissions[],
                                           int [] grantResults) {
        super.onRequestPermissionsResult(
                requestCode, permissions, grantResults);

        AutoPermissions.Companion.parsePermissions(this, requestCode,
                permissions, this);
    }
```  

* LoginActivity 클래스의 onCreate 메서드에 권한 요청하는 코드를 추가  
```java
AutoPermissions.Companion.loadAllPermissions(this, 101);

=>LoginActivity 클래스에 위치 정보가 갱신될 때 호출되는 리스너 클래스를 생성
     class GPSListener implements LocationListener {
        //위치 정보를 처음 받거나 갱신된 경우 호출되는 메서드
        @Override
        public void onLocationChanged(@NonNull Location location) {
            //위도와 경도 가져오기
            latitude = location.getLatitude();
            longitude = location.getLongitude();
        }

        @Override
        public void onStatusChanged(String provider, int status, Bundle extras) {
            LocationListener.super.onStatusChanged(provider, status, extras);
        }

        @Override
        public void onProviderEnabled(@NonNull String provider) {
            LocationListener.super.onProviderEnabled(provider);
        }

        @Override
        public void onProviderDisabled(@NonNull String provider) {
            LocationListener.super.onProviderDisabled(provider);
        }
    }
```  

* LoginActivity 클래스의 onCreate 메서드에 위치 정보 갱신을 위한 코드를 추가  
```java
        LocationManager manager =
                (LocationManager)getSystemService(Context.LOCATION_SERVICE);
        try {
            Location location = manager.getLastKnownLocation(
                    LocationManager.GPS_PROVIDER);
            if (location != null) {
                Double latitude = location.getLatitude();
                Double longitude = location.getLongitude();

            }
            GPSListener gpsListener = new GPSListener();
            long minTime = 10000;
            float minDistance = 0;
            manager.requestLocationUpdates(
                    LocationManager.GPS_PROVIDER, minTime, minDistance, gpsListener);
        }catch(SecurityException e){
            Log.e("위치 정보 사용 오류", e.getLocalizedMessage());
        }
```

* LoginActivity 클래스의 로그인 성공했을 때 수행되는 코드 부분의 finish() 호출 구문 앞에 작성  
```java
if(latitude != null && longitude != null){
                                    //서버에게 전송
                                    url = new URL("http://192.168.10.8:9000/logininfo/location?"
                                            + "latitude=" + latitude + "&longitude=" + longitude + "&email=" + email);
                                    con = (HttpURLConnection)url.openConnection();
                                    con.setUseCaches(false);
                                    con.setConnectTimeout(30000);

                                    br = new BufferedReader(new InputStreamReader(con.getInputStream()));
                                    sb = new StringBuilder();

                                    while(true){
                                        String line = br.readLine();
                                        if(line == null){
                                            break;
                                        }
                                        sb.append(line + "\n");
                                    }
                                    br.close();
                                    con.disconnect();
                                }

```  

## 13. 관점 지향 프로그래밍을 이용한 로그기록
### 1) AOP(Aspect Oriented Programming) - 관점 지향 프로그래밍  
* 객체 지향 프로그래밍의 단점을 보완하기 위한 프로그래밍 기법  
* 메서드나 클래스를 관점에 따라 분리싴켜서 구현하는 프로그래밍 기법  
* Spring Boot MVC 구조  

클라이언트(Front End) <---- Request(DTO 구조), Response(View, JSON과 같은 데이터) ----> Controller(요청을 확인해서 필요한 서비스를 호출하고 서비스의 결과를 클라이언트에게 전송) <---- DTO ----> Service(비즈니스 로직을 호출하고 저장소관련 API를 호출) <-----> Entity <----> 저장소 관련 Framework(Hibernate-JPA, MyBatis)를 포함하거나 순수 데이터베이스 관련 코드를 소유하고 있는 Repository클래스 또는 인터페이스 <--------> 저장소  

* 로그 기록과 같은 비즈니스 로직은 아닌 Common Concern 또는 Cross Cutting Concern(공통 관심 사항)를 어디에 작성할 지에 대한 문제가 발생하는데, 기존의 방식에서는 Service에 작성을 하거나 별도의 클래스를 만들어서 Service에서 호출하는 구조로 만들었습니다.  
Java Web Programming이나 Spring Framework에서는 이를 별도로 작성하고 설정을 한 후, 컴파일이나 런타임 시에 위빙하는 구조를 이용할 수 있도록 했는데, 이렇게 함으로써 비즈니스 로직과 공통 관심 사항을 분리시켜 가독성을 좋게 하고, 유지보수를 편리하게 했습니다.  

### 2) Spring Framework를 이용한 AOP 구현 방법  
#### 1) Filter  
Java Web Programming(Servlet)에서 제공  
Servlet 단위에서 실행  
요청과 응답을 거른 뒤 정제하는 역할을 주로 수행  
생성 - Filter인터페이스를 implements한 클래스를 생성  
    init()  
    doFilter() : 전 후 처리를 위한 메서드  
    destroy()  
설정 - web.xml 파일에 작성  
<filter>  
    <filter-name>필터이름</filter-name>  
    <filter-class>필터 클래스 경로</filter-class>  
    <init-param>  
        <param-name>파라미터 이름</param-name>  
        <param-value>파라미터 값</param-value>
    </init-param>
</filter>
<filter-mapping>  
    <filter-name>필터이름</filter-name>  
    <url-pattern>필터가 동작할 URL 패턴</url-pattern>  
</filter-mapping>  

#### 2) Interceptor  
Spring에서 제공, Servlet 단위에서 실행, 스프링 컨텍스트 외부에 존재하여 스프링과 무관한 자원에 대해서 동작  
스프링의 모든 빈 객체에 접근할 수 있음  
* 생성 -> HandlerInterceptor 인터페이스를 implements  
    preHandler() : 컨트롤러의 메서드가 호출되기 전  
    postHandler() : 컨트롤러의 메서드가 실행된 후 View 페이지가 랜더링 되기 전  
    afterCompletion() : 컨트롤러의 메서드가 실행된 후 View 페이지가 랜더링 된 후  

* 설정 : 스프링 설정 파일이나 환경설정 클래스 이용  
    public class 클래스이름 implements WebMvcConfigure{
        @Override
        public addInterceptors(InterceptorRegistry registry){
            registry.addInterceptor(인터셉터 인스턴스).addPathPatterns("인터셉터가 동작할 URL패턴");
        } 
    }

* 특정 URL에 따른 동작을 만들고자 할 때 주로 이용  

#### 3) AOP  
Spring에서 제공, Proxy 패턴의 형태로 실행 -> 클래스가 있으면 이 클래스를 상속받은 별도의 클래스를 만들어서 사용하는 방식으로 호출하는 당사자는 자신이 처음에 만든 클래스의 인스턴스를 사용하는 것처럼 느끼도록 하는 방식  

클라이언트(외부네트워크에 요청하는 방식으로 요청) -> Proxy Server -> 외부 네트워크  

* 전체 흐름
Client(ServletRequest) -> Filter -> DispatcherServlet -> Interceptor -> AOP -> Controller -> Interceptor -> DispatcherServlet -> Filter -> Client(ServletResponse)

* Filter는 주로 걸러내는 역할을 하고, 응답을 할 때 데이터에 변형을 가하면 Filter라는 이름 대신에 Wrapper라는 표현을 사용하기도 합니다.  
* 특정 이벤트가 발생할 때는 호출되는 것은 Listner라고 하기도 합니다.  
* 메서드가 호출되기 전이나 후에 동작하는 방식으로 설정  
* Filter나 Interceptor는 ServletRequest나 ServletResponse를 메서드의 파라미터로 이용하지만 AOP에서는 JoinPoint나 PreceedingJoinPoint를 이용  

* 포인트 것 - 호출 시점  
    @Before  
    @After  
    @After-returning  
    @After-throwing  
    @Around : 메서드 수행 전과 후  

메서드 호출 시점이냐 url이냐에 따라 선택해서 사용  