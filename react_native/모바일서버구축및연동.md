# Mobile을 위한 Server 구축  
## 1. 개발 환경
* 데이터 베이스 : MySQL  
* 프로그래밍 언어 : Java  
* 프레임워크 : Spring Boot  
* IDE : STS  
* 버전 관리 : git hub  

## 2. 데이터 베이스 작업  
* 데이터베이스에 접속해서 이번 프로젝트에 사용할 데이터베이스를 생성  
create database choc;

## 3. Spring Boot Project 생성  
* build : gradle  
* 의존성 : spring dev tools, lombok, spring data jpa, mysql, spring web, thymeleaf  

## 4. 기본 설정  
### 1) application.properties에 작성  
```ini
# 서버 실행 포트 정보
server.port = 80

# 데이터베이스 접속 정보
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/choc?useUnicode=yes&characterEncoding=UTF-8&serverTimezon=UTC
spring.datasource.username=root
spring.datasource.password=1234

# 데이터베이스 사용 옵션 정보
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
spring.jpa.properties.hibernate.show_sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.ddl-auto=update
logging.level.org.hibernate.type.descriptor.sql=trace

#Live Reload
spring.devtools.livereload.enabled=true
```  

### 2) 외부 라이브러리의 의존성을 설정 - BCrypt(복호화가 되지 않은 암호화를 위한 라이브러리 - spring security를 사용하는 경우에는 불필요)
* build.gradle 파일의 dependecies파일에 작성  
// https://mvnrepository.com/artifact/org.mindrot/jbcrypt
implementation group: 'org.mindrot', name: 'jbcrypt', version: '0.4'

* 프로젝트 rebuild  

### 3) 데이터베이스 관련 기본 작업
* main 함수를 가진 클래스에 데이터베이스의 변경내용을 감시할 수 있도록 어노테이션을 설정  
@EnableJpaAuditing
```java
// 자바에서는 @가 붙은 단어를 Annotaion이라고 하고, Python에서는 Decorator라고 합니다.
// 자주 사용하는 코드를 하나의 클래스로 만든 후 이 클래스의 수행 코드를 예약어 형태로 만든 것입니다.
// 이런 코드를 Annotation을 이용해서 만들 수도 있고, AOP를 이용해서 설정하는 것도 가능합니다.
@EnableJpaAuditing
@SpringBootApplication
public class MobileServerApplication {

	public static void main(String[] args) {
		SpringApplication.run(MobileServerApplication.class, args);
	}

}
```  

* Entity들에서 자주 사용하는 속성(생성 날짜, 수정 날짜)들을 위한 Entity를 생성 : model.BaseEntity  
```java
// 테이블로 생성하지 말고 매핑 정보만 사용하겠다라는 의미
@MappedSuperclass
// Entity의 변경사항이 발생했을 때 작업을 수행
@EntityListeners(value= {AuditingEntityListener.class})
// Lombok 라이브러리에서 속성의 getter 메서드를 만들어주는 어노테이션
@Getter
public class BaseEntity {
	// 생성날짜를 이용
	@CreatedDate
	// 테이블에 만들어 질 떄는 regdate라는 컬럼으로 생성되고 수정은 할 수 없음
	@Column(name="regdate", updatable=false)
	private LocalDateTime regDate;

	// 마지막 수정 날짜를 이용
	@LastModifiedDate
	// 테이블에 만들어질 때는 moddate라는 컬럼으로 생성
	@Column(name="moddate")
	private LocalDateTime modDate;
}
```  

## 5. Entity 작업  
* 2개의 테이블을 생성  
하나의 테이블은 회원 정보이고 다른 하나의 테이블은 아이템 정보  
회원은 여러 개의 아이템을 등록할 수 있고 하나의 아이템은 하나의 회원만 등록이 가능  

* Entity를 만들고 application.properties파일에 spring.jpa.properties.hibernate.ddl-auto=update 옵션을 설정하면 테이블이 없으면 테이블이 자동으로 만들어지지만 실제 업무에서는 이 방식을 사용하지 않는데, 컬럼의 순서가 임의로 생성되고, 제약족건의 이름도 임의로 생성됩니다. 애플리케이션 프로그램이 DDL이나 DCL작업을 수행하는 것을 권장하지 않기 째문입니다.  

### 1) 데이터베이스에 접속해서 테이블을 생성하는 구문을 수행  
* sql 실행
```sql
create table tbl_member(
    email varchar(255) not null,
    password varchar(255) not null,
    name varchar(255),
    imageurl varchar(255),
    regdate datetime(6),
    moddate datetime(6),
    lastlogindate datetime(6),
    primary key(email)
)engine=InnoDB DEFAULT CHARSET=utf8;

create table item(
	itemid INTEGER primary key auto_increment,
	itemname varchar(100),
	price Integer,
	description varchar(200),
	pictureurl varchar(255)
    member_email varchar(255)
)engine=InnoDB DEFAULT CHARSET=utf8;
```  

### 2) tbl_member테이블과 연결할 Entity 생성model/Member.java 작성
```java
// 데이터벱이스의 테이블과 연결된 Entity로 설정
@Entity
// 연결할 테이블 이름 설정
@Table(name="tbl_member")
// Builder패턴으로 인스턴스를 생성하도록 해주는 어노테이션
@Builder
// 모든 속성을 매개변수로 하는 생성자를 생성
@AllArgsConstructor
// 매개변수가 없는 DefaultConstructor 생성
@NoArgsConstructor
@Getter
// 모든 속성의 toString을 호출한 결과를가지고 toString을 생성
@ToString
public class Member extends BaseEntity{
	@Id
	private String email;
	private String password;
	private String name;
	private String imageurl;
	private LocalDateTime lastlogindate;
}
```  

### 3) Item테이블과 연결할 Entity 생성 - model/Item.java  
```java
package com.choc.model;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.ManyToOne;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;

@Entity
@Builder
@AllArgsConstructor
@NoArgsConstructor
@Data
@ToString(exclude="member") // member.toString은 제외
public class Item {
	@Id
	// 기본키 값을 auto_increment나 sequence를 이용해서 자동 생성
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long itemid;
	@Column(length=100, nullable = false)
	private String itemname;
	@Column
	private Integer price;
	@Column(length = 200)
	private String description;
	@Column(length = 255)
	private String pictureurl;
	
	// 사용을 할 때 데이터를 가져오겠다는 옵션
	@ManyToOne(fetch=FetchType.LAZY)
	private Member member;
}
```  

## 6. Repository 작업  
### +)  Jpa에서 데이터베이스를 사용하는 방법  
#### 1. JpaRepository가 제공하는 기본 메서드를 사용하는 방법  
* Entity를 이용한 데이터 삽입, 데이터 수정(Id를 기준으로 수정), 데이터 삭제(Id를 기준으로 삭제)  
* id를 이용한 삭제 제공  
* 테이블의 전체 데이터를 조회, Pageable을 이용한 조회, 기본키를 이용한 조회  
#### 2. 메서드 이름을 이용하는 방법  
* 기능 + Entity이름(생략가능) + By + 컬럼이름으로 메서드를 생성  
* 조회와 삭제 가능
* 연산자(크다, 작다, 작거나 같다, 크거나 같다, 사이, like 등) 사용 가능  
* name을 이용한 데이터 조회 : findByName(String name)
* name을 이용한 삭제 : deleteByName(String name)  
#### 3. JPQL을 이용하는 방법 - join이 필요할 때 주로 이용  
@Query("쿼리")  
매서드이름(@Param("파라미터이름") 자료형 매개변수 이름 ... )  
#### 4. QueryDsl을 이용해서 JPQL을 동적으로 생성하는 방법  
* 값을 변경하는 쿼리는 정적으로 생성이 가능  
* 테이블 이름이나 컬럼이름을 변경해야 하는 경우는 **QueryDsl**을 이용해야 합니다.  
* 입력받은 값을 이용해서 title에서 조회 
	~> title = 입력받은 값, 이런 경우는 JPQL로 처리가 가능  
* 값을 입력받아서 어떤 경우에는 title에서 조회하고 다른 경우에는 content에서 조회해야 하는 경우  
	~> 이런 경우에는 JPQL을 동적으로 생성해야 합니다. 이 경우 "QueryDsl" 사용  

### 1) Member Entity작업을 위한 Repository 인터페이스 생성 - persistence.MemberRepository  
```java
// JpaRepository를 상속 받을 때는 Entity이름과 Id로 설정한 속성의 자료형이 필요
public interface MemberRepository extends JpaRepository<Member, String> {
	// 회원가입
	// 로그인
	// 회원 정보 가져오기
	// 회원 정보 수정
	// 회원 탈퇴
}
```  

### 2) test디렉터리에 Repository를 테스트할 수 있는 클래스를 만들고 테스트 - Repositorytest.java  
```java
package com.choc;

import java.util.Optional;

import org.junit.jupiter.api.Test;
import org.mindrot.jbcrypt.BCrypt;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import com.choc.model.Member;
import com.choc.persistence.MemberRepository;

@SpringBootTest
public class RepositoryTest {
	@Autowired
	private MemberRepository m;
	
	// Member에 데이터 삽입
	//@Test
	public void testRegisterMember() {
		/*
		Member member = Member.builder().email("dntksemfdj473@gmail.com")
				.password("159753").name("촉촉한초코칩").imageurl("chocochip.png").build();
		m.save(member);
		*/
		
		// BCrypt 사용해보기
		/*
		String password = BCrypt.hashpw("159753", BCrypt.gensalt()); 
		// 같은 데이터를 가지고 암호화해도 매번 다른 값이 나옴
		System.out.println(password);
		System.out.println(BCrypt.checkpw("159753", password)); // 평문이 같으면 true
		*/
		// password에 String 형태로 hash된 값이 들어간 것이 확인됨
		String password = BCrypt.hashpw("159753", BCrypt.gensalt());
		Member member = Member.builder().email("dntksemfdj473@gmail.com")
				.password(password).name("촉촉한초코칩").imageurl("chocochip.png").build();
		m.save(member);
	}
	
	// 회원 정보 가져오기 - 수정이나 로그인에서 사용  
	//@Test
	public void testGetMember() {
		Optional<Member> optional = m.findById("dntksemfdj473@gmail.com");
		if(optional.isPresent()) {
			Member member = optional.get();
			System.out.println(member); // 로그인은 데이터를 가져와서 비교하면 됨!
		}else {
			System.out.println("존재하지 않는 데이터입니다.");
		}
	}
	
	// 데이터 수정
	//@Test
	public void testUpdateMember() {
		String password = BCrypt.hashpw("111111", BCrypt.gensalt());
		Member member = Member.builder().email("dntksemfdj473@gmail.com")
				.password(password).name("칙촉").imageurl("user.png").build();
		
		m.save(member);
	}
	
	// 데이터 삭제
	@Test
	public void testDeleteMember() {
		// 2가지 방법 존재
		Member member = Member.builder().email("dntksemfdj473@gmail.com").build();
		m.delete(member);
		

		//m.deleteById("dntksemfdj473@gmail.com");
	}

	//이름으로 데이터 조회
	//@Test
	public void testFindName() {
		String name="칙촉";
		List<Member> list = m.findMemberByName(name);
		System.out.println(list);
		
		name = "촉촉한초코칩";
		list = m.findMemberByName(name);
		System.out.println(list);
		
	}
}
```  

### 3) Item테이블을 위한Repository 인터페이스 생성 - persistence.ItemRepository  
```java
public interface ItemRepository extends JpaRepository<Item, Long>{
	
	// Member를 이용해서 Member가 작성한 모든 Item을 조회하는 메서드
	List<Item> findItemByMember(Member member);
}
```

### 4) 이전에 만든 Test클래스에 코드를 추가하고 확인
```java
// ... 생략 ... 
	
	@SpringBootTest
	public class RepositoryTest {
	// ... 생략 ... 
	
	@Autowired
	private ItemRepository i;
	
	// Item 삽입을 테스트
	//@Test
	void testRegisterItem() {
		// 외래키를 생성
		Member member = Member.builder().email("dntksemfdj473@gmail.com").build();
		for(int j = 0; j< 100; j++) {
			Item item = Item.builder().itemname("사과").price(2500).description("비타민 C가 풍부합니다.")
				.pictureurl("apple.png").member(member).build();
			i.save(item);
		}
	}
	
	// 데이터 전체 보기 테스트
	//@Test
	public void getAll() {
		List<Item> list = i.findAll();
		System.out.println(list);
	}
	
	// 페이징과 정렬
	//@Test
	public void getPaging() {
		Sort sort = Sort.by("itemid").descending();
		Pageable pageable = PageRequest.of(0, 10);
		Page<Item> list = i.findAll(pageable);
		list.get().forEach(item-> {System.out.println(item);});
	}
	
	// 외래키를 이용한 조회
	//@Test
	public void getFindMember() {
		Member member = Member.builder().email("dntksemfdj473@gmail.com").build();
		List<Item> list = i.findItemByMember(member);
		System.out.println(list);
	}
	
	// 데이터 1개 가져오기
	//@Test
	public void getItem() {
		Optional<Item> item = i.findById(10L);
		if(item.isPresent()) {
			System.out.println(item.get());
		}else {
			System.out.println("데이터가 없습니다.");
		}
	}
	
	// 데이터 수정
	//@Test
	public void updateItem() {
		Member member = Member.builder().email("dntksemfdj473@gmail.com").build();
		Item item = Item.builder().itemid(10L).itemname("아오리사과").description("달고 아삭아삭해요~")
				.price(3450).pictureurl("greenapple.png").member(member).build();
		i.save(item);
	}
	
	// 데이터 삭제
	@Test
	public void deleteItem(){
		Item item = Item.builder().itemid(100L).build();
		i.delete(item);
	}
}
```  

## 7. Service 작업  
### 1) Member 요청을 처리할(파라미터를 받고 결과를 출력) DTO 클래스 생성 - dto.MemberDTO  
```java
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class MemberDTO {
	private String email;
	private String password;
	private String name;
	private String imageurl;
	// 전송된 파일의 내용을 저장할 속성
	private MultipartFile image;
	private LocalDateTime lastlogindate;
	private LocalDateTime regdate;
	private LocalDateTime moddate;
}
```  

### 2) Member 요청을 처리할 메서드의 원형을 가진 인터페이스 생성 - service.MemberService  
```java
public interface MemberService {
	// 데이터 삽입
	public String registerMember(MemberDTO dto);
	public MemberDTO loginMember(MemberDTO dto);
	public MemberDTO getMember(MemberDTO dto);
	public String updateMember(MemberDTO dto);
	public String deleteMember(MemberDTO dto);
	
	// DTO클래스의 객체를 Model클래스의 객체로 변환
	public default Member dtoToEntity(MemberDTO dto) {
		String password = BCrypt.hashpw(dto.getPassword(), BCrypt.gensalt());
		Member member = Member.builder().email(dto.getEmail()).name(dto.getName()).password(password)
				.imageurl(dto.getImageurl()).lastlogindate(dto.getLastlogindate()).build();
		
		return member;
	}
	
	// Model클래스의 객체를 DTO클래스의 객체로 변환
	public default MemberDTO entityToDto(Member member) {
		MemberDTO dto = MemberDTO.builder().email(member.getEmail()).name(member.getName()).imageurl(member.getImageurl())
				.regdate(member.getRegDate()).moddate(member.getModDate()).lastlogindate(member.getLastlogindate()).build();
		return dto;
	}
}
```

### 3) Memeber요청을 처리할 메서드를 구현한 MemberServiceImpl 클래스를 생성하고 작성  
```java
package com.choc.service;

import com.choc.dto.MemberDTO;
import com.choc.model.Member;
import com.choc.persistence.MemberRepository;

import lombok.RequiredArgsConstructor;

import java.util.List;
import java.util.Optional;

import org.mindrot.jbcrypt.BCrypt;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class MemberServiceImpl implements MemberService{
	private final MemberRepository memberRepository;
	
	@Override
	public String registerMember(MemberDTO dto) {
		Member member = dtoToEntity(dto);
		// 이메일 중복체크
		Optional<Member> optional = memberRepository.findById(dto.getEmail());
		if(optional.isPresent()) {
			return "존재하는 이메일";
		}
		// 이름 중복 체크
		List<Member> list = memberRepository.findMemberByName(dto.getName());
		if(list.size() > 0) {
			return "존재하는 이름";
		}
		memberRepository.save(member);
		return member.getEmail();
	}

	@Override
	public MemberDTO loginMember(MemberDTO dto) {
		// 이메일을 가지고 데이터를 찾아옴
		Optional<Member> optional = memberRepository.findById(dto.getEmail());
		
		if(optional.isPresent()) { // 존재하는 이메일
			// 비밀번호 확인
			Member member = optional.get();
			if(BCrypt.checkpw(dto.getPassword(), member.getPassword())) {
				return entityToDto(member);
			}//else {
			//	return null;
			//}
		}//else { // 존재하지 않는 이메일
		//	return null;
		//}
		return null;
	}

	@Override
	public MemberDTO getMember(MemberDTO dto) {
		// 이메일을 가지고 데이터를 찾아옴
		Optional<Member> optional = memberRepository.findById(dto.getEmail());
		
		if(optional.isPresent()) { // 존재하는 이메일
			// 비밀번호 확인
			Member member = optional.get();
			if(BCrypt.checkpw(dto.getPassword(), member.getPassword())) {
				return entityToDto(member);
			}//else {
			//	return null;
			//}
		}
		return null;
	}

	@Override
	public String updateMember(MemberDTO dto) {
		Member member =dtoToEntity(dto);
		memberRepository.save(member);
		return member.getEmail();
	}

	@Override
	public String deleteMember(MemberDTO dto) {
		Member member = dtoToEntity(dto);
		memberRepository.delete(member);
		return member.getEmail();
	}

}
```

### 4) Service 계층을 테스트하기 위한 클래스를 생성하고 작성  
```java
@SpringBootTest
public class ServiceTest {
	@Autowired
	private MemberService m;
	
	// 회원가입 테스트
	//@Test
	public void testRegisterMember() {
		// 처음 추가를 할때는 성공, email과 name이 중복된 데이터면 실패
		MemberDTO dto = MemberDTO.builder().email("youremail@site.com").password("yourpw")
				.name("yourname").imageurl("yourimg.png").build();
		
		String result = m.registerMember(dto);
		System.out.println(result);
	}
	
	// 회원 정보 가져오기
	//@Test
	public void testGetMember() {
		MemberDTO dto = MemberDTO.builder().email("youremail@site.com").build();
		MemberDTO result = m.getMember(dto);
		System.out.println(result);
	}
	
	// 로그인 테스트
	@Test
	public void testLoginMember() {
		MemberDTO dto = MemberDTO.builder().email("youremail@site.com").password("yourpw").build();
		MemberDTO result = m.loginMember(dto);
		System.out.println(result);
		
		// 오늘 날짜를 생성
		Date date = new Date();
		SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");
		String d = sdf.format(date);
		try {
			// true값 주면 같은 이름의 파일에 append
			FileOutputStream fos = new FileOutputStream("C:\\Users\\SAMSUNG\\Desktop\\java\\chocchic.github.io\\react_native\\MobileServer\\"+ d + ".txt", true);
			PrintWriter pw  = new PrintWriter(fos);
			pw.println("내용");
			pw.flush();
			pw.close();
		}catch(Exception e) {
			
		}
	}
	
	// 멤버 수정 테스트
	//@Test
	public void updateMember() {
		MemberDTO dto = MemberDTO.builder().email("youremail@site.com").name("NAME").password("pw1234")
				.imageurl("user.png").build();
		String result = m.updateMember(dto);
		System.out.println(result);
	}
	
	// 멤버 삭제 테스트
	@Test
	public void deleteMember() {
		MemberDTO dto = MemberDTO.builder().email("youremail@site.com").build();
		String result = m.deleteMember(dto);
		System.out.println(result);
	}
}
```  

### 5) ItemEntity를 Controller나 Service에서 사용하기 위한 ItemDTO클래스를 생성하고 작성  
```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ItemDTO {
	private Long itemid;
	private String itemname;
	private Integer price;
	private String description;
	// 업로드된 이미지 경로를 저장
	private String pictureurl;
	// 파일을 받아오기 위한 변수
	private MultipartFile image;
	// Entity를 만들 때는 Entity를 외래키로 추가하지만 화면 입출력할 때는 필요한 데이터만 선언  
	private String email;
}
```  

### 6) 페이지 단위 요청을 위한 DTO - dto/PageRequestDTO  
```java
@Data
@Builder
@AllArgsConstructor
public class PageRequestItemDTO {
	// 페이지 번호 - 1부터 시작
	private int page;
	// 한 페이지에 보여질 데이터 개수
	private int size;
	// 특정 항목으로 조회하고자 하는 경우
	//private String condition;
	//private String keyword;
	
	// 생성자
	public PageRequestItemDTO() {
		page = 1;
		size =10;
	}
	// 페이지 번호와 데이터 개수를 가지고 Pageable 객체를 생성해주는 메서드
	public Pageable getPageable(Sort sort) {
		// JPA에서는 페이지번호가 0부터 시작하기 때문에 page-1을 해주어야 뷰에서는 1부터 시작하고, DB에서는 0부터 페이징가능
		return PageRequest.of(page-1,size,sort);
	}
}
```  

### 7) 페이지단위로 출력을 하기 위한 DTO - dto/PageResponseItemDTO  
```java
@Data
public class PageResponseItemDTO {
	// Dto 리스트
	private List<Item> itemList;
	
	// 전체 페이지 개수
	private int totalPage;
	// 현재 페이지 번호
	private int page;
	
	// 페이지 번호 목록 크기
	private int size;
	// 출력할 페이지 번호 시작과 종료
	private int start, end;
	
	// 이전과 다음 여부
	private boolean prev,next;
	//페이지 번호 목록
	private List<Integer> pageList;
	
	// 페이지 번호 목록을 만들어주는 메서드
	public void makePageList(Pageable pageable) {
		page = pageable.getPageNumber()+1;
		size = pageable.getPageSize();
		
		int tempEnd = (int)(Math.ceil(page/10.0))*10;
		start = tempEnd - 9;
		prev = start > 1;
		end = totalPage > tempEnd ? tempEnd : totalPage;
		next = tempEnd < totalPage;
		pageList = IntStream.rangeClosed(start, end).boxed().collect(Collectors.toList());
	}
	
}
```  

### 8) Item 요청을 처리할 메서드의 원형을 가진 서비스 인터페이스를 생성 - service/ItemService
```java
public interface ItemService {
	// 아이템 등록
	public Long registerItem(ItemDTO dto);
	// 하나의 아이템 가져오기
	public ItemDTO getItem(ItemDTO dto);
	// 아이템 수정
	public Long updateItem(ItemDTO dto);
	// 아이템 삭제
	public Long deleteItem(ItemDTO dto);
	
	// 페이지 단위로 데이터가져오기
	public PageResponseItemDTO getList(PageRequestItemDTO dto);
	
	// DTO를 Entity로 변환해주는 메서드
	public default Item dtoToEntity(ItemDTO dto) {
		Item item = Item.builder().itemid(dto.getItemid()).itemname(dto.getItemname()).price(dto.getPrice())
				.description(dto.getDescription()).pictureurl(dto.getPictureurl())
				.member(Member.builder().email(dto.getEmail()).build()).build();
		return item;
	}
	
	// Entity를 DTO로 변환해주는 메서드
	public default ItemDTO entitytoDto(Item item) {
		ItemDTO dto = ItemDTO.builder().itemid(item.getItemid()).itemname(item.getItemname()).price(item.getPrice())
				.description(item.getDescription()).pictureurl(item.getPictureurl()).email(item.getMember().getEmail()).build();
		return dto;
	}
}
```  

### 9) Item에 대한 요청을 처리하는 메서드를 구현할 ServiceImpl클래스를 생성하고 메서드 구현  
```java
@Service
@RequiredArgsConstructor
public class ItemServiceImpl implements ItemService{
	private final ItemRepository itemRepository;
	
	@Override
	public Long registerItem(ItemDTO dto) {
		Item item = dtoToEntity(dto);
		itemRepository.save(item);
		return item.getItemid();
	}

	@Override
	public ItemDTO getItem(ItemDTO dto) {
		Long itemid = dto.getItemid();
		Optional<Item> op = itemRepository.findById(itemid);
		if(op.isPresent()) {
			return entitytoDto(op.get());
		}
		return null;
	}

	@Override
	public Long updateItem(ItemDTO dto) {
		Item item = dtoToEntity(dto);
		Long itemid = item.getItemid();
		itemRepository.save(item);
		return itemid;
	}

	@Override
	public Long deleteItem(ItemDTO dto) {
		Item item = dtoToEntity(dto);
		Long itemid = item.getItemid();
		itemRepository.deleteById(itemid);
		return itemid;
	}

	@Override
	public PageResponseItemDTO getList(PageRequestItemDTO dto) {
		Sort sort = Sort.by("itemid").descending();
		Pageable pageable = PageRequest.of(dto.getPage()-1, dto.getSize(), sort);
		Page<Item> page = itemRepository.findAll(pageable);
		PageResponseItemDTO result = new PageResponseItemDTO();
		result.makePageList(pageable);
		result.setTotalPage(page.getTotalPages());
		List<Item> list = new ArrayList<>();
		page.get().forEach(item -> {
			list.add(item);
		});
		result.setItemList(list);
		return null;
	}

}
```  

### 10) Test클래스에서 테스트  
```java
@SpringBootTest
public class ServiceTest {
// ... 생략 ...
	
	@Autowired
	private ItemService itemService;
	
	// 데이터 삽입
	//@Test
	public void testregisterItem() {
		for(int i = 0; i<100; i++) {
			ItemDTO dto = ItemDTO.builder().itemname("apple_"+i).price(3000).description("사과_"+i).pictureurl("apple_"+i+".png")
					.email("dntksemfdj473@gmail.com").build();
			Long itemid = itemService.registerItem(dto);
			System.out.println(itemid);
		}
	}
	// 데이터 1개 가져오기
	//@Test
	public void testGetItem() {
		ItemDTO dto = ItemDTO.builder().itemid(101L).build();
		System.out.println(itemService.getItem(dto));
	}
	
	// 페이지 단위로 가져오기
	//@Test
	public void testGetList() {
		PageRequestItemDTO dto = PageRequestItemDTO.builder().page(2).size(10).build();
		PageResponseItemDTO result = itemService.getList(dto);
		System.out.println(result);
	}
	
	// 데이터 수정
	//@Test
	public void testUpdateItem() {
		ItemDTO dto = ItemDTO.builder().itemid(16L).itemname("apple_0616수정").price(6000).description("수정된 사과")
				.pictureurl("apple__0616수정")
				.email("dntksemfdj473@gmail.com").build();
		Long itemid = itemService.updateItem(dto);
		System.out.println(itemid);
	}
	
	// Item 삭제
	@Test
	public void testDeleteItem() {
		ItemDTO dto = ItemDTO.builder().itemid(23L).build();
		Long itemid = itemService.deleteItem(dto);
		System.out.println(itemid);
	}
}
```  
## 8. 파일 업로드 처리를 위한 설정
* 실제 제품을 만들어서 배포할 때는 이 부부은 다시 수정됩니다.  
코드가 수정되는 것은 아니고 파일 업로드 위치를 수정합니다.  
운영환경에서는 역할별로 컴퓨터를 물리적으로 분할하는 것이 일반적입니다.  
데이터베이스, 애플리케이션, 파일 저장소 등을 물리적으로 분할합니다.  

* 파일 저장소를 설정하는 방법도 예전에는 별도의 파일 서버를 이용했지만 최근에는 클라우드를 많이 이용합니다.  

* 개발자나 서비스를 구현하고자 하는 경우네는 요즈음같은 경우는 기본적인클라우드 사용법을 먼저 익히는 것이 좋습니다. 파일 서버 활용이나 데이터베이스 서버 그리고 운영환경을 만드는 부분을 공부해 두는 것이 좋습니다.  
우리나라의 경우 중소기업이나 중견기업의 경우 AWS를 압도적으로 많이 사용합니다.  
대기엽의 경우는 마이크로소프트의 애저 서비스도 이용합니다.

### 1) 업로드된 파일을 저장할 위치를 결정  

### 2) application.properties파일에 파일 업로드 관련 설정 추가  
* +) 개발환경과 운영환경이 분리된 경우에는 개발 환경에서 운영환경으로 이전할때(이행 - Migration) 변경될 가능성  
```ini
# 파일 업로드 관련 설정
spring.servlet.multipart.enabled=true
spring.servlet.multipart.location=C:\\Users\\SAMSUNG\\Documents\\data
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=30MB

# 환경의 변화가 생겼을 떄 수정할 정적 상수를 속성으로 생성
com.choc.upload.path=C:\\Users\\SAMSUNG\\Documents\\data
```  

## 9. Member요청 처리 작업  
### 1)기본 준비 작업
* 삽입, 삭제, 갱신 요청에 대한 응답을 위한 클래스를 생성 - ResponseMemberDTO: MemberDTO에 error 속성만 수정해도 됨
```java
@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ResponseMemberDTO {
	private String error;
	private String email;
	private String password;
	private String name;
	private String imageurl;
	private LocalDateTime lastlogindate;
	private LocalDateTime regdate;
	private LocalDateTime moddate;
}
``` 

* Member 요청을 처리할 MemberController를 생성하고 기본적인 구조를 생성  
```java
@RestController
@RequestMapping("member")
public class MemberController {
	@Autowired
	private MemberService memberService;
}
```  

### 2)데이터 삽입(회원 가입 처리)  
* MemberServiceImpl 클래스에 파일 업로드 경로를 가져오기 위한 속성을 추가  
```java
	//application.properties 파일에 작성한 속성 가져오기
	@Value("${com.adamsoft.upload.path}")
	private String uploadPath;
```  

* MemberServiceImpl 클래스에 이미지 파일이 업로드 될 디렉토리를 생성해주는 메서드를 생성  
```java
	//업로드한 날짜 별로 이미지를 저장하기 위해서 날짜별로 디렉토리를 만들어서 경로를 리턴하는 메서드
	private String makeFolder() {
		//오늘 날짜를 문자열로 생성
		String str = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy/MM/dd"));
		//문자열을 치환 - /를 운영체제의 디렉토리 구분자로 치환
		String realUploadPath = str.replace("//", File.separator);
		//디렉토리 생성
		File uploadPathDir = new File(uploadPath, realUploadPath);
		if(uploadPathDir.exists() == false) {
			uploadPathDir.mkdirs();
		}
		return realUploadPath;
		
	}
```  

* MemberServiceImpl 클래스에 파일 업로드를 처리하기 위해서 데이터 삽입 요청 처리 메서드를 수정  
```java
	@Override
	public String registerMember(MemberDTO dto) {
		Member member = dtoToEntity(dto);
		//이메일 중복 체크 - 별도로 구성할 수 있음
		Optional<Member> optional = memberRepository.findById(dto.getEmail());
		if(optional.isPresent()) {
			return "존재하는 이메일";
		}
		
		//이름 중복 체크 - 별도로 구성할 수 있음
		List<Member> list = memberRepository.findMemberByName(dto.getName());
		if(list.size() > 0) {
			return "존재하는 이름";
		}
		
		//파일 업로드 처리
		//전송 받은 파일을 가져오기
		MultipartFile uploadFile = dto.getImage();
		//전송된 파일이 있다면
		if(uploadFile.isEmpty() == false) {
			//이미지 파일 만 업로드하기 위해서 이미지 파일이 아니면 작업 중단
			if(uploadFile.getContentType().startsWith("image") == false) {
				return null;
			}
			//원본 파일의 파일 이름 찾아오기
			String originalName = uploadFile.getOriginalFilename();
			String fileName = originalName.substring(originalName.lastIndexOf("\\") + 1);
			
			//파일을 업로드할 디렉토리 경로를 생성
			String realUploadPath = makeFolder();
			
			//업로드 할 파일의 경로를 생성
			String uuid = UUID.randomUUID().toString(); //파일 이름의 중복을 피하기 위해서 생성
			String saveName = uploadPath + File.separator + 
					realUploadPath + File.separator + uuid + fileName;
			Path savePath = Paths.get(saveName);
			try {
				//파일 업로드
				uploadFile.transferTo(savePath);
			}catch(Exception e) {
				System.out.println(e.getLocalizedMessage());
			}
			//이미지 경로를 DTO에 설정
			dto.setImageurl(realUploadPath + File.separator + uuid + fileName);
		}
		member = dtoToEntity(dto);
		memberRepository.save(member);
		return member.getEmail();
	}
```  

* MemberController 클래스에 회원 가입 요청을 처리하는 메서드를 작성  
```java
	@PostMapping("/register")
	public ResponseEntity<?> registerMember(MemberDTO dto){
		ResponseMemberDTO response = null;
		try {
			//데이터 삽입 처리
			String email = memberService.registerMember(dto);
			response = ResponseMemberDTO.builder().email(email).build();
		}catch(Exception e) {
			String error = e.getMessage();
			response = ResponseMemberDTO.builder().error(error).build();
		}
		return ResponseEntity.ok().body(response);
	}
```  

* PostMan을 이용해서 테스트: RestController는 출력되는 화면이 없기 때문에 PostMan  같은 도구를 이용해서 테스트  

### 3) 로그인 처리  
* MemberController클래스에 로그인 요청을 처리하는 메서드 생성  
```java

```