# Mobile을 위한 Server 구축  
## 1. 개발 환경
* 데이터 베이스 : MySQL  
* 프로그래밍 언어 : Java  
* 프레임워크 : Spring Boot  
* IDE : STS  
* 버전 관리 : git hub  

## 2. 데이터 베이스 작업  
* 데이터베이스에 접속해서 이번 프로젝트에 사용할 데이터베이스를 생성  
create database choc;

## 3. Spring Boot Project 생성  
* build : gradle  
* 의존성 : spring dev tools, lombok, spring data jpa, mysql, spring web, thymeleaf  

## 4. 기본 설정  
### 1) application.properties에 작성  
```ini
# 서버 실행 포트 정보
server.port = 80

# 데이터베이스 접속 정보
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/choc?useUnicode=yes&characterEncoding=UTF-8&serverTimezon=UTC
spring.datasource.username=root
spring.datasource.password=1234

# 데이터베이스 사용 옵션 정보
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
spring.jpa.properties.hibernate.show_sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.ddl-auto=update
logging.level.org.hibernate.type.descriptor.sql=trace

#Live Reload
spring.devtools.livereload.enabled=true
```  

### 2) 외부 라이브러리의 의존성을 설정 - BCrypt(복호화가 되지 않은 암호화를 위한 라이브러리 - spring security를 사용하는 경우에는 불필요)
* build.gradle 파일의 dependecies파일에 작성  
// https://mvnrepository.com/artifact/org.mindrot/jbcrypt
implementation group: 'org.mindrot', name: 'jbcrypt', version: '0.4'

* 프로젝트 rebuild  

### 3) 데이터베이스 관련 기본 작업
* main 함수를 가진 클래스에 데이터베이스의 변경내용을 감시할 수 있도록 어노테이션을 설정  
@EnableJpaAuditing
```java
// 자바에서는 @가 붙은 단어를 Annotaion이라고 하고, Python에서는 Decorator라고 합니다.
// 자주 사용하는 코드를 하나의 클래스로 만든 후 이 클래스의 수행 코드를 예약어 형태로 만든 것입니다.
// 이런 코드를 Annotation을 이용해서 만들 수도 있고, AOP를 이용해서 설정하는 것도 가능합니다.
@EnableJpaAuditing
@SpringBootApplication
public class MobileServerApplication {

	public static void main(String[] args) {
		SpringApplication.run(MobileServerApplication.class, args);
	}

}
```  

* Entity들에서 자주 사용하는 속성(생성 날짜, 수정 날짜)들을 위한 Entity를 생성 : model.BaseEntity  
```java
// 테이블로 생성하지 말고 매핑 정보만 사용하겠다라는 의미
@MappedSuperclass
// Entity의 변경사항이 발생했을 때 작업을 수행
@EntityListeners(value= {AuditingEntityListener.class})
// Lombok 라이브러리에서 속성의 getter 메서드를 만들어주는 어노테이션
@Getter
public class BaseEntity {
	// 생성날짜를 이용
	@CreatedDate
	// 테이블에 만들어 질 떄는 regdate라는 컬럼으로 생성되고 수정은 할 수 없음
	@Column(name="regdate", updatable=false)
	private LocalDateTime regDate;

	// 마지막 수정 날짜를 이용
	@LastModifiedDate
	// 테이블에 만들어질 때는 moddate라는 컬럼으로 생성
	@Column(name="moddate")
	private LocalDateTime modDate;
}
```  

## 5. Entity 작업  
* 2개의 테이블을 생성  
하나의 테이블은 회원 정보이고 다른 하나의 테이블은 아이템 정보  
회원은 여러 개의 아이템을 등록할 수 있고 하나의 아이템은 하나의 회원만 등록이 가능  

* Entity를 만들고 application.properties파일에 spring.jpa.properties.hibernate.ddl-auto=update 옵션을 설정하면 테이블이 없으면 테이블이 자동으로 만들어지지만 실제 업무에서는 이 방식을 사용하지 않는데, 컬럼의 순서가 임의로 생성되고, 제약족건의 이름도 임의로 생성됩니다. 애플리케이션 프로그램이 DDL이나 DCL작업을 수행하는 것을 권장하지 않기 째문입니다.  

### 1) 데이터베이스에 접속해서 테이블을 생성하는 구문을 수행  
* sql 실행
```sql
create table tbl_member(
    email varchar(255) not null,
    password varchar(255) not null,
    name varchar(255),
    imageurl varchar(255),
    regdate datetime(6),
    moddate datetime(6),
    lastlogindate datetime(6),
    primary key(email)
)engine=InnoDB DEFAULT CHARSET=utf8;

create table item(
	itemid INTEGER primary key auto_increment,
	itemname varchar(100),
	price Integer,
	description varchar(200),
	pictureurl varchar(255)
    member_email varchar(255)
)engine=InnoDB DEFAULT CHARSET=utf8;
```  

### 2) model/member.java 작성
```java
// 데이터벱이스의 테이블과 연결된 Entity로 설정
@Entity
// 연결할 테이블 이름 설정
@Table(name="tbl_member")
// Builder패턴으로 인스턴스를 생성하도록 해주는 어노테이션
@Builder
// 모든 속성을 매개변수로 하는 생성자를 생성
@AllArgsConstructor
// 매개변수가 없는 DefaultConstructor 생성
@NoArgsConstructor
@Getter
// 모든 속성의 toString을 호출한 결과를가지고 toString을 생성
@ToString
public class Member extends BaseEntity{
	@Id
	private String email;
	private String password;
	private String name;
	private String imageurl;
	private LocalDateTime lastlogindate;
}
```  