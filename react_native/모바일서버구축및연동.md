# Mobile을 위한 Server 구축  
## 1. 개발 환경
* 데이터 베이스 : MySQL  
* 프로그래밍 언어 : Java  
* 프레임워크 : Spring Boot  
* IDE : STS  
* 버전 관리 : git hub  

## 2. 데이터 베이스 작업  
* 데이터베이스에 접속해서 이번 프로젝트에 사용할 데이터베이스를 생성  
create database choc;

## 3. Spring Boot Project 생성  
* build : gradle  
* 의존성 : spring dev tools, lombok, spring data jpa, mysql, spring web, thymeleaf  

## 4. 기본 설정  
### 1) application.properties에 작성  
```ini
# 서버 실행 포트 정보
server.port = 80

# 데이터베이스 접속 정보
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/choc?useUnicode=yes&characterEncoding=UTF-8&serverTimezon=UTC
spring.datasource.username=root
spring.datasource.password=1234

# 데이터베이스 사용 옵션 정보
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
spring.jpa.properties.hibernate.show_sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.ddl-auto=update
logging.level.org.hibernate.type.descriptor.sql=trace

#Live Reload
spring.devtools.livereload.enabled=true
```  

### 2) 외부 라이브러리의 의존성을 설정 - BCrypt(복호화가 되지 않은 암호화를 위한 라이브러리 - spring security를 사용하는 경우에는 불필요)
* build.gradle 파일의 dependecies파일에 작성  
// https://mvnrepository.com/artifact/org.mindrot/jbcrypt
implementation group: 'org.mindrot', name: 'jbcrypt', version: '0.4'

* 프로젝트 rebuild  

### 3) 데이터베이스 관련 기본 작업
* main 함수를 가진 클래스에 데이터베이스의 변경내용을 감시할 수 있도록 어노테이션을 설정  
@EnableJpaAuditing
```java
// 자바에서는 @가 붙은 단어를 Annotaion이라고 하고, Python에서는 Decorator라고 합니다.
// 자주 사용하는 코드를 하나의 클래스로 만든 후 이 클래스의 수행 코드를 예약어 형태로 만든 것입니다.
// 이런 코드를 Annotation을 이용해서 만들 수도 있고, AOP를 이용해서 설정하는 것도 가능합니다.
@EnableJpaAuditing
@SpringBootApplication
public class MobileServerApplication {

	public static void main(String[] args) {
		SpringApplication.run(MobileServerApplication.class, args);
	}

}
```  

* Entity들에서 자주 사용하는 속성(생성 날짜, 수정 날짜)들을 위한 Entity를 생성 : model.BaseEntity  
```java
// 테이블로 생성하지 말고 매핑 정보만 사용하겠다라는 의미
@MappedSuperclass
// Entity의 변경사항이 발생했을 때 작업을 수행
@EntityListeners(value= {AuditingEntityListener.class})
// Lombok 라이브러리에서 속성의 getter 메서드를 만들어주는 어노테이션
@Getter
public class BaseEntity {
	// 생성날짜를 이용
	@CreatedDate
	// 테이블에 만들어 질 떄는 regdate라는 컬럼으로 생성되고 수정은 할 수 없음
	@Column(name="regdate", updatable=false)
	private LocalDateTime regDate;

	// 마지막 수정 날짜를 이용
	@LastModifiedDate
	// 테이블에 만들어질 때는 moddate라는 컬럼으로 생성
	@Column(name="moddate")
	private LocalDateTime modDate;
}
```  

## 5. Entity 작업  
* 2개의 테이블을 생성  
하나의 테이블은 회원 정보이고 다른 하나의 테이블은 아이템 정보  
회원은 여러 개의 아이템을 등록할 수 있고 하나의 아이템은 하나의 회원만 등록이 가능  

* Entity를 만들고 application.properties파일에 spring.jpa.properties.hibernate.ddl-auto=update 옵션을 설정하면 테이블이 없으면 테이블이 자동으로 만들어지지만 실제 업무에서는 이 방식을 사용하지 않는데, 컬럼의 순서가 임의로 생성되고, 제약족건의 이름도 임의로 생성됩니다. 애플리케이션 프로그램이 DDL이나 DCL작업을 수행하는 것을 권장하지 않기 째문입니다.  

### 1) 데이터베이스에 접속해서 테이블을 생성하는 구문을 수행  
* sql 실행
```sql
create table tbl_member(
    email varchar(255) not null,
    password varchar(255) not null,
    name varchar(255),
    imageurl varchar(255),
    regdate datetime(6),
    moddate datetime(6),
    lastlogindate datetime(6),
    primary key(email)
)engine=InnoDB DEFAULT CHARSET=utf8;

create table item(
	itemid INTEGER primary key auto_increment,
	itemname varchar(100),
	price Integer,
	description varchar(200),
	pictureurl varchar(255)
    member_email varchar(255)
)engine=InnoDB DEFAULT CHARSET=utf8;
```  

### 2) tbl_member테이블과 연결할 Entity 생성model/Member.java 작성
```java
// 데이터벱이스의 테이블과 연결된 Entity로 설정
@Entity
// 연결할 테이블 이름 설정
@Table(name="tbl_member")
// Builder패턴으로 인스턴스를 생성하도록 해주는 어노테이션
@Builder
// 모든 속성을 매개변수로 하는 생성자를 생성
@AllArgsConstructor
// 매개변수가 없는 DefaultConstructor 생성
@NoArgsConstructor
@Getter
// 모든 속성의 toString을 호출한 결과를가지고 toString을 생성
@ToString
public class Member extends BaseEntity{
	@Id
	private String email;
	private String password;
	private String name;
	private String imageurl;
	private LocalDateTime lastlogindate;
}
```  

### 3) Item테이블과 연결할 Entity 생성 - model/Item.java  
```java
package com.choc.model;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.ManyToOne;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;

@Entity
@Builder
@AllArgsConstructor
@NoArgsConstructor
@Data
@ToString(exclude="member") // member.toString은 제외
public class Item {
	@Id
	// 기본키 값을 auto_increment나 sequence를 이용해서 자동 생성
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long itemid;
	@Column(length=100, nullable = false)
	private String itemname;
	@Column
	private Integer price;
	@Column(length = 200)
	private String description;
	@Column(length = 255)
	private String pictureurl;
	
	// 사용을 할 때 데이터를 가져오겠다는 옵션
	@ManyToOne(fetch=FetchType.LAZY)
	private Member member;
}
```  

## 6. Repository 작업  
### +)  Jpa에서 데이터베이스를 사용하는 방법  
#### 1. JpaRepository가 제공하는 기본 메서드를 사용하는 방법  
* Entity를 이용한 데이터 삽입, 데이터 수정(Id를 기준으로 수정), 데이터 삭제(Id를 기준으로 삭제)  
* id를 이용한 삭제 제공  
* 테이블의 전체 데이터를 조회, Pageable을 이용한 조회, 기본키를 이용한 조회  
#### 2. 메서드 이름을 이용하는 방법  
* 기능 + Entity이름(생략가능) + By + 컬럼이름으로 메서드를 생성  
* 조회와 삭제 가능
* 연산자(크다, 작다, 작거나 같다, 크거나 같다, 사이, like 등) 사용 가능  
* name을 이용한 데이터 조회 : findByName(String name)
* name을 이용한 삭제 : deleteByName(String name)  
#### 3. JPQL을 이용하는 방법 - join이 필요할 때 주로 이용  
@Query("쿼리")  
매서드이름(@Param("파라미터이름") 자료형 매개변수 이름 ... )  
#### 4. QueryDsl을 이용해서 JPQL을 동적으로 생성하는 방법  
* 값을 변경하는 쿼리는 정적으로 생성이 가능  
* 테이블 이름이나 컬럼이름을 변경해야 하는 경우는 **QueryDsl**을 이용해야 합니다.  
* 입력받은 값을 이용해서 title에서 조회 
	~> title = 입력받은 값, 이런 경우는 JPQL로 처리가 가능  
* 값을 입력받아서 어떤 경우에는 title에서 조회하고 다른 경우에는 content에서 조회해야 하는 경우  
	~> 이런 경우에는 JPQL을 동적으로 생성해야 합니다. 이 경우 "QueryDsl" 사용  

### 1) Member Entity작업을 위한 Repository 인터페이스 생성 - persistence.MemberRepository  
```java
// JpaRepository를 상속 받을 때는 Entity이름과 Id로 설정한 속성의 자료형이 필요
public interface MemberRepository extends JpaRepository<Member, String> {
	// 회원가입
	// 로그인
	// 회원 정보 가져오기
	// 회원 정보 수정
	// 회원 탈퇴
}
```  

### 2) test디렉터리에 Repository를 테스트할 수 있는 클래스를 만들고 테스트 - Repositorytest.java  
```java
package com.choc;

import java.util.Optional;

import org.junit.jupiter.api.Test;
import org.mindrot.jbcrypt.BCrypt;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import com.choc.model.Member;
import com.choc.persistence.MemberRepository;

@SpringBootTest
public class RepositoryTest {
	@Autowired
	private MemberRepository m;
	
	// Member에 데이터 삽입
	//@Test
	public void testRegisterMember() {
		/*
		Member member = Member.builder().email("dntksemfdj473@gmail.com")
				.password("159753").name("촉촉한초코칩").imageurl("chocochip.png").build();
		m.save(member);
		*/
		
		// BCrypt 사용해보기
		/*
		String password = BCrypt.hashpw("159753", BCrypt.gensalt()); 
		// 같은 데이터를 가지고 암호화해도 매번 다른 값이 나옴
		System.out.println(password);
		System.out.println(BCrypt.checkpw("159753", password)); // 평문이 같으면 true
		*/
		// password에 String 형태로 hash된 값이 들어간 것이 확인됨
		String password = BCrypt.hashpw("159753", BCrypt.gensalt());
		Member member = Member.builder().email("dntksemfdj473@gmail.com")
				.password(password).name("촉촉한초코칩").imageurl("chocochip.png").build();
		m.save(member);
	}
	
	// 회원 정보 가져오기 - 수정이나 로그인에서 사용  
	//@Test
	public void testGetMember() {
		Optional<Member> optional = m.findById("dntksemfdj473@gmail.com");
		if(optional.isPresent()) {
			Member member = optional.get();
			System.out.println(member); // 로그인은 데이터를 가져와서 비교하면 됨!
		}else {
			System.out.println("존재하지 않는 데이터입니다.");
		}
	}
	
	// 데이터 수정
	//@Test
	public void testUpdateMember() {
		String password = BCrypt.hashpw("111111", BCrypt.gensalt());
		Member member = Member.builder().email("dntksemfdj473@gmail.com")
				.password(password).name("칙촉").imageurl("user.png").build();
		
		m.save(member);
	}
	
	// 데이터 삭제
	@Test
	public void testDeleteMember() {
		// 2가지 방법 존재
		Member member = Member.builder().email("dntksemfdj473@gmail.com").build();
		m.delete(member);
		

		//m.deleteById("dntksemfdj473@gmail.com");
	}

	//이름으로 데이터 조회
	//@Test
	public void testFindName() {
		String name="칙촉";
		List<Member> list = m.findMemberByName(name);
		System.out.println(list);
		
		name = "촉촉한초코칩";
		list = m.findMemberByName(name);
		System.out.println(list);
		
	}
}
```  

### 3) Item테이블을 위한Repository 인터페이스 생성 - persistence.ItemRepository  
```java
public interface ItemRepository extends JpaRepository<Item, Long>{
	
	// Member를 이용해서 Member가 작성한 모든 Item을 조회하는 메서드
	List<Item> findItemByMember(Member member);
}
```

### 4) 이전에 만든 Test클래스에 코드를 추가하고 확인
```java
// ... 생략 ... 
	
	@SpringBootTest
	public class RepositoryTest {
	// ... 생략 ... 
	
	@Autowired
	private ItemRepository i;
	
	// Item 삽입을 테스트
	//@Test
	void testRegisterItem() {
		// 외래키를 생성
		Member member = Member.builder().email("dntksemfdj473@gmail.com").build();
		for(int j = 0; j< 100; j++) {
			Item item = Item.builder().itemname("사과").price(2500).description("비타민 C가 풍부합니다.")
				.pictureurl("apple.png").member(member).build();
			i.save(item);
		}
	}
	
	// 데이터 전체 보기 테스트
	//@Test
	public void getAll() {
		List<Item> list = i.findAll();
		System.out.println(list);
	}
	
	// 페이징과 정렬
	//@Test
	public void getPaging() {
		Sort sort = Sort.by("itemid").descending();
		Pageable pageable = PageRequest.of(0, 10);
		Page<Item> list = i.findAll(pageable);
		list.get().forEach(item-> {System.out.println(item);});
	}
	
	// 외래키를 이용한 조회
	//@Test
	public void getFindMember() {
		Member member = Member.builder().email("dntksemfdj473@gmail.com").build();
		List<Item> list = i.findItemByMember(member);
		System.out.println(list);
	}
	
	// 데이터 1개 가져오기
	//@Test
	public void getItem() {
		Optional<Item> item = i.findById(10L);
		if(item.isPresent()) {
			System.out.println(item.get());
		}else {
			System.out.println("데이터가 없습니다.");
		}
	}
	
	// 데이터 수정
	//@Test
	public void updateItem() {
		Member member = Member.builder().email("dntksemfdj473@gmail.com").build();
		Item item = Item.builder().itemid(10L).itemname("아오리사과").description("달고 아삭아삭해요~")
				.price(3450).pictureurl("greenapple.png").member(member).build();
		i.save(item);
	}
	
	// 데이터 삭제
	@Test
	public void deleteItem(){
		Item item = Item.builder().itemid(100L).build();
		i.delete(item);
	}
}
```  

## 7. Service 작업  
### 1) Member 요청을 처리할(파라미터를 받고 결과를 출력) DTO 클래스 생성 - dto.MemberDTO  
```java
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class MemberDTO {
	private String email;
	private String password;
	private String name;
	private String imageurl;
	// 전송된 파일의 내용을 저장할 속성
	private MultipartFile image;
	private LocalDateTime lastlogindate;
	private LocalDateTime regdate;
	private LocalDateTime moddate;
}
```  

### 2) Member 요청을 처리할 메서드의 원형을 가진 인터페이스 생성 - service.MemberService  
```java
public interface MemberService {
	// 데이터 삽입
	public String registerMember(MemberDTO dto);
	public MemberDTO loginMember(MemberDTO dto);
	public MemberDTO getMember(MemberDTO dto);
	public String updateMember(MemberDTO dto);
	public String deleteMember(MemberDTO dto);
	
	// DTO클래스의 객체를 Model클래스의 객체로 변환
	public default Member dtoToEntity(MemberDTO dto) {
		String password = BCrypt.hashpw(dto.getPassword(), BCrypt.gensalt());
		Member member = Member.builder().email(dto.getEmail()).name(dto.getName()).password(password)
				.imageurl(dto.getImageurl()).lastlogindate(dto.getLastlogindate()).build();
		
		return member;
	}
	
	// Model클래스의 객체를 DTO클래스의 객체로 변환
	public default MemberDTO entityToDto(Member member) {
		MemberDTO dto = MemberDTO.builder().email(member.getEmail()).name(member.getName()).imageurl(member.getImageurl())
				.regdate(member.getRegDate()).moddate(member.getModDate()).lastlogindate(member.getLastlogindate()).build();
		return dto;
	}
}
```

### 3) Memeber요청을 처리할 메서드를 구현한 MemberServiceImpl 클래스를 생성하고 작성  
```java
package com.choc.service;

import com.choc.dto.MemberDTO;
import com.choc.model.Member;
import com.choc.persistence.MemberRepository;

import lombok.RequiredArgsConstructor;

import java.util.List;
import java.util.Optional;

import org.mindrot.jbcrypt.BCrypt;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class MemberServiceImpl implements MemberService{
	private final MemberRepository memberRepository;
	
	@Override
	public String registerMember(MemberDTO dto) {
		Member member = dtoToEntity(dto);
		// 이메일 중복체크
		Optional<Member> optional = memberRepository.findById(dto.getEmail());
		if(optional.isPresent()) {
			return "존재하는 이메일";
		}
		// 이름 중복 체크
		List<Member> list = memberRepository.findMemberByName(dto.getName());
		if(list.size() > 0) {
			return "존재하는 이름";
		}
		memberRepository.save(member);
		return member.getEmail();
	}

	@Override
	public MemberDTO loginMember(MemberDTO dto) {
		// 이메일을 가지고 데이터를 찾아옴
		Optional<Member> optional = memberRepository.findById(dto.getEmail());
		
		if(optional.isPresent()) { // 존재하는 이메일
			// 비밀번호 확인
			Member member = optional.get();
			if(BCrypt.checkpw(dto.getPassword(), member.getPassword())) {
				return entityToDto(member);
			}//else {
			//	return null;
			//}
		}//else { // 존재하지 않는 이메일
		//	return null;
		//}
		return null;
	}

	@Override
	public MemberDTO getMember(MemberDTO dto) {
		// 이메일을 가지고 데이터를 찾아옴
		Optional<Member> optional = memberRepository.findById(dto.getEmail());
		
		if(optional.isPresent()) { // 존재하는 이메일
			// 비밀번호 확인
			Member member = optional.get();
			if(BCrypt.checkpw(dto.getPassword(), member.getPassword())) {
				return entityToDto(member);
			}//else {
			//	return null;
			//}
		}
		return null;
	}

	@Override
	public String updateMember(MemberDTO dto) {
		Member member =dtoToEntity(dto);
		memberRepository.save(member);
		return member.getEmail();
	}

	@Override
	public String deleteMember(MemberDTO dto) {
		Member member = dtoToEntity(dto);
		memberRepository.delete(member);
		return member.getEmail();
	}

}
```

### 4) Service 계층을 테스트하기 위한 클래스를 생성하고 작성  
```java
@SpringBootTest
public class ServiceTest {
	@Autowired
	private MemberService m;
	
	// 회원가입 테스트
	//@Test
	public void testRegisterMember() {
		// 처음 추가를 할때는 성공, email과 name이 중복된 데이터면 실패
		MemberDTO dto = MemberDTO.builder().email("youremail@site.com").password("yourpw")
				.name("yourname").imageurl("yourimg.png").build();
		
		String result = m.registerMember(dto);
		System.out.println(result);
	}
	
	// 회원 정보 가져오기
	//@Test
	public void testGetMember() {
		MemberDTO dto = MemberDTO.builder().email("youremail@site.com").build();
		MemberDTO result = m.getMember(dto);
		System.out.println(result);
	}
	
	// 로그인 테스트
	@Test
	public void testLoginMember() {
		MemberDTO dto = MemberDTO.builder().email("youremail@site.com").password("yourpw").build();
		MemberDTO result = m.loginMember(dto);
		System.out.println(result);
		
		// 오늘 날짜를 생성
		Date date = new Date();
		SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");
		String d = sdf.format(date);
		try {
			// true값 주면 같은 이름의 파일에 append
			FileOutputStream fos = new FileOutputStream("C:\\Users\\SAMSUNG\\Desktop\\java\\chocchic.github.io\\react_native\\MobileServer\\"+ d + ".txt", true);
			PrintWriter pw  = new PrintWriter(fos);
			pw.println("내용");
			pw.flush();
			pw.close();
		}catch(Exception e) {
			
		}
	}
	
	// 멤버 수정 테스트
	//@Test
	public void updateMember() {
		MemberDTO dto = MemberDTO.builder().email("youremail@site.com").name("NAME").password("pw1234")
				.imageurl("user.png").build();
		String result = m.updateMember(dto);
		System.out.println(result);
	}
	
	// 멤버 삭제 테스트
	@Test
	public void deleteMember() {
		MemberDTO dto = MemberDTO.builder().email("youremail@site.com").build();
		String result = m.deleteMember(dto);
		System.out.println(result);
	}
}
```  

### 5) ItemEntity를 Controller나 Service에서 사용하기 위한 ItemDTO클래스를 생성하고 작성  
```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ItemDTO {
	private Long itemid;
	private String itemname;
	private Integer price;
	private String description;
	// 업로드된 이미지 경로를 저장
	private String pictureurl;
	// 파일을 받아오기 위한 변수
	private MultipartFile image;
	// Entity를 만들 때는 Entity를 외래키로 추가하지만 화면 입출력할 때는 필요한 데이터만 선언  
	private String email;
}
```  

### 6) 페이지 단위 요청을 위한 DTO - dto/PageRequestDTO  
```java
@Data
@Builder
@AllArgsConstructor
public class PageRequestItemDTO {
	// 페이지 번호 - 1부터 시작
	private int page;
	// 한 페이지에 보여질 데이터 개수
	private int size;
	// 특정 항목으로 조회하고자 하는 경우
	//private String condition;
	//private String keyword;
	
	// 생성자
	public PageRequestItemDTO() {
		page = 1;
		size =10;
	}
	// 페이지 번호와 데이터 개수를 가지고 Pageable 객체를 생성해주는 메서드
	public Pageable getPageable(Sort sort) {
		// JPA에서는 페이지번호가 0부터 시작하기 때문에 page-1을 해주어야 뷰에서는 1부터 시작하고, DB에서는 0부터 페이징가능
		return PageRequest.of(page-1,size,sort);
	}
}
```  

### 7) 페이지단위로 출력을 하기 위한 DTO - dto/PageResponseItemDTO  
```java

```