# Mobile을 위한 Server 구축  
## 1. 개발 환경
* 데이터 베이스 : MySQL  
* 프로그래밍 언어 : Java  
* 프레임워크 : Spring Boot  
* IDE : STS  
* 버전 관리 : git hub  

## 2. 데이터 베이스 작업  
* 데이터베이스에 접속해서 이번 프로젝트에 사용할 데이터베이스를 생성  
create database choc;

## 3. Spring Boot Project 생성  
* build : gradle  
* 의존성 : spring dev tools, lombok, spring data jpa, mysql, spring web, thymeleaf  

## 4. 기본 설정  
### 1) application.properties에 작성  
```ini
# 서버 실행 포트 정보
server.port = 80

# 데이터베이스 접속 정보
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/choc?useUnicode=yes&characterEncoding=UTF-8&serverTimezon=UTC
spring.datasource.username=root
spring.datasource.password=1234

# 데이터베이스 사용 옵션 정보
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
spring.jpa.properties.hibernate.show_sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.ddl-auto=update
logging.level.org.hibernate.type.descriptor.sql=trace

#Live Reload
spring.devtools.livereload.enabled=true
```  

### 2) 외부 라이브러리의 의존성을 설정 - BCrypt(복호화가 되지 않은 암호화를 위한 라이브러리 - spring security를 사용하는 경우에는 불필요)
* build.gradle 파일의 dependecies파일에 작성  
// https://mvnrepository.com/artifact/org.mindrot/jbcrypt
implementation group: 'org.mindrot', name: 'jbcrypt', version: '0.4'

* 프로젝트 rebuild  

### 3) 데이터베이스 관련 기본 작업
* main 함수를 가진 클래스에 데이터베이스의 변경내용을 감시할 수 있도록 어노테이션을 설정  
@EnableJpaAuditing
```java
// 자바에서는 @가 붙은 단어를 Annotaion이라고 하고, Python에서는 Decorator라고 합니다.
// 자주 사용하는 코드를 하나의 클래스로 만든 후 이 클래스의 수행 코드를 예약어 형태로 만든 것입니다.
// 이런 코드를 Annotation을 이용해서 만들 수도 있고, AOP를 이용해서 설정하는 것도 가능합니다.
@EnableJpaAuditing
@SpringBootApplication
public class MobileServerApplication {

	public static void main(String[] args) {
		SpringApplication.run(MobileServerApplication.class, args);
	}

}
```  

* Entity들에서 자주 사용하는 속성(생성 날짜, 수정 날짜)들을 위한 Entity를 생성 : model.BaseEntity  
```java
// 테이블로 생성하지 말고 매핑 정보만 사용하겠다라는 의미
@MappedSuperclass
// Entity의 변경사항이 발생했을 때 작업을 수행
@EntityListeners(value= {AuditingEntityListener.class})
// Lombok 라이브러리에서 속성의 getter 메서드를 만들어주는 어노테이션
@Getter
public class BaseEntity {
	// 생성날짜를 이용
	@CreatedDate
	// 테이블에 만들어 질 떄는 regdate라는 컬럼으로 생성되고 수정은 할 수 없음
	@Column(name="regdate", updatable=false)
	private LocalDateTime regDate;

	// 마지막 수정 날짜를 이용
	@LastModifiedDate
	// 테이블에 만들어질 때는 moddate라는 컬럼으로 생성
	@Column(name="moddate")
	private LocalDateTime modDate;
}
```  

## 5. Entity 작업  
* 2개의 테이블을 생성  
하나의 테이블은 회원 정보이고 다른 하나의 테이블은 아이템 정보  
회원은 여러 개의 아이템을 등록할 수 있고 하나의 아이템은 하나의 회원만 등록이 가능  

* Entity를 만들고 application.properties파일에 spring.jpa.properties.hibernate.ddl-auto=update 옵션을 설정하면 테이블이 없으면 테이블이 자동으로 만들어지지만 실제 업무에서는 이 방식을 사용하지 않는데, 컬럼의 순서가 임의로 생성되고, 제약족건의 이름도 임의로 생성됩니다. 애플리케이션 프로그램이 DDL이나 DCL작업을 수행하는 것을 권장하지 않기 째문입니다.  

### 1) 데이터베이스에 접속해서 테이블을 생성하는 구문을 수행  
* sql 실행
```sql
create table tbl_member(
    email varchar(255) not null,
    password varchar(255) not null,
    name varchar(255),
    imageurl varchar(255),
    regdate datetime(6),
    moddate datetime(6),
    lastlogindate datetime(6),
    primary key(email)
)engine=InnoDB DEFAULT CHARSET=utf8;

create table item(
	itemid INTEGER primary key auto_increment,
	itemname varchar(100),
	price Integer,
	description varchar(200),
	pictureurl varchar(255)
    member_email varchar(255)
)engine=InnoDB DEFAULT CHARSET=utf8;
```  

### 2) tbl_member테이블과 연결할 Entity 생성model/Member.java 작성
```java
// 데이터벱이스의 테이블과 연결된 Entity로 설정
@Entity
// 연결할 테이블 이름 설정
@Table(name="tbl_member")
// Builder패턴으로 인스턴스를 생성하도록 해주는 어노테이션
@Builder
// 모든 속성을 매개변수로 하는 생성자를 생성
@AllArgsConstructor
// 매개변수가 없는 DefaultConstructor 생성
@NoArgsConstructor
@Getter
// 모든 속성의 toString을 호출한 결과를가지고 toString을 생성
@ToString
public class Member extends BaseEntity{
	@Id
	private String email;
	private String password;
	private String name;
	private String imageurl;
	private LocalDateTime lastlogindate;
}
```  

### 3) Item테이블과 연결할 Entity 생성 - model/Item.java  
```java
package com.choc.model;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.ManyToOne;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;

@Entity
@Builder
@AllArgsConstructor
@NoArgsConstructor
@Data
@ToString(exclude="member") // member.toString은 제외
public class Item {
	@Id
	// 기본키 값을 auto_increment나 sequence를 이용해서 자동 생성
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long itemid;
	@Column(length=100, nullable = false)
	private String itemname;
	@Column
	private Integer price;
	@Column(length = 200)
	private String description;
	@Column(length = 255)
	private String pictureurl;
	
	// 사용을 할 때 데이터를 가져오겠다는 옵션
	@ManyToOne(fetch=FetchType.LAZY)
	private Member member;
}
```  

## 6. Repository 작업  
### +)  Jpa에서 데이터베이스를 사용하는 방법  
#### 1. JpaRepository가 제공하는 기본 메서드를 사용하는 방법  
* Entity를 이용한 데이터 삽입, 데이터 수정(Id를 기준으로 수정), 데이터 삭제(Id를 기준으로 삭제)  
* id를 이용한 삭제 제공  
* 테이블의 전체 데이터를 조회, Pageable을 이용한 조회, 기본키를 이용한 조회  
#### 2. 메서드 이름을 이용하는 방법  
* 기능 + Entity이름(생략가능) + By + 컬럼이름으로 메서드를 생성  
* 조회와 삭제 가능
* 연산자(크다, 작다, 작거나 같다, 크거나 같다, 사이, like 등) 사용 가능  
* name을 이용한 데이터 조회 : findByName(String name)
* name을 이용한 삭제 : deleteByName(String name)  
#### 3. JPQL을 이용하는 방법 - join이 필요할 때 주로 이용  
@Query("쿼리")  
매서드이름(@Param("파라미터이름") 자료형 매개변수 이름 ... )  
#### 4. QueryDsl을 이용해서 JPQL을 동적으로 생성하는 방법  
* 값을 변경하는 쿼리는 정적으로 생성이 가능  
* 테이블 이름이나 컬럼이름을 변경해야 하는 경우는 **QueryDsl**을 이용해야 합니다.  
* 입력받은 값을 이용해서 title에서 조회 
	~> title = 입력받은 값, 이런 경우는 JPQL로 처리가 가능  
* 값을 입력받아서 어떤 경우에는 title에서 조회하고 다른 경우에는 content에서 조회해야 하는 경우  
	~> 이런 경우에는 JPQL을 동적으로 생성해야 합니다. 이 경우 "QueryDsl" 사용  

### 1) Member Entity작업을 위한 Repository 인터페이스 생성 - persistence.MemberRepository  
```java
// JpaRepository를 상속 받을 때는 Entity이름과 Id로 설정한 속성의 자료형이 필요
public interface MemberRepository extends JpaRepository<Member, String> {
	// 회원가입
	// 로그인
	// 회원 정보 가져오기
	// 회원 정보 수정
	// 회원 탈퇴
}
```  

### 2) test디렉터리에 Repository를 테스트할 수 있는 클래스를 만들고 테스트 - Repositorytest.java  
```java
package com.choc;

import java.util.Optional;

import org.junit.jupiter.api.Test;
import org.mindrot.jbcrypt.BCrypt;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import com.choc.model.Member;
import com.choc.persistence.MemberRepository;

@SpringBootTest
public class RepositoryTest {
	@Autowired
	private MemberRepository m;
	
	// Member에 데이터 삽입
	//@Test
	public void testRegisterMember() {
		/*
		Member member = Member.builder().email("dntksemfdj473@gmail.com")
				.password("159753").name("촉촉한초코칩").imageurl("chocochip.png").build();
		m.save(member);
		*/
		
		// BCrypt 사용해보기
		/*
		String password = BCrypt.hashpw("159753", BCrypt.gensalt()); 
		// 같은 데이터를 가지고 암호화해도 매번 다른 값이 나옴
		System.out.println(password);
		System.out.println(BCrypt.checkpw("159753", password)); // 평문이 같으면 true
		*/
		// password에 String 형태로 hash된 값이 들어간 것이 확인됨
		String password = BCrypt.hashpw("159753", BCrypt.gensalt());
		Member member = Member.builder().email("dntksemfdj473@gmail.com")
				.password(password).name("촉촉한초코칩").imageurl("chocochip.png").build();
		m.save(member);
	}
	
	// 회원 정보 가져오기 - 수정이나 로그인에서 사용  
	//@Test
	public void testGetMember() {
		Optional<Member> optional = m.findById("dntksemfdj473@gmail.com");
		if(optional.isPresent()) {
			Member member = optional.get();
			System.out.println(member); // 로그인은 데이터를 가져와서 비교하면 됨!
		}else {
			System.out.println("존재하지 않는 데이터입니다.");
		}
	}
	
	// 데이터 수정
	//@Test
	public void testUpdateMember() {
		String password = BCrypt.hashpw("111111", BCrypt.gensalt());
		Member member = Member.builder().email("dntksemfdj473@gmail.com")
				.password(password).name("칙촉").imageurl("user.png").build();
		
		m.save(member);
	}
	
	// 데이터 삭제
	@Test
	public void testDeleteMember() {
		// 2가지 방법 존재
		Member member = Member.builder().email("dntksemfdj473@gmail.com").build();
		m.delete(member);
		

		//m.deleteById("dntksemfdj473@gmail.com");
	}

	//이름으로 데이터 조회
	//@Test
	public void testFindName() {
		String name="칙촉";
		List<Member> list = m.findMemberByName(name);
		System.out.println(list);
		
		name = "촉촉한초코칩";
		list = m.findMemberByName(name);
		System.out.println(list);
		
	}
}
```  

### 3) Item테이블을 위한Repository 인터페이스 생성 - persistence.ItemRepository  
```java
public interface ItemRepository extends JpaRepository<Item, Long>{
	
	// Member를 이용해서 Member가 작성한 모든 Item을 조회하는 메서드
	List<Item> findItemByMember(Member member);
}
```

### 4) 이전에 만든 Test클래스에 코드를 추가하고 확인
```java
// ... 생략 ... 
	
	@SpringBootTest
	public class RepositoryTest {
	// ... 생략 ... 
	
	@Autowired
	private ItemRepository i;
	
	// Item 삽입을 테스트
	//@Test
	void testRegisterItem() {
		// 외래키를 생성
		Member member = Member.builder().email("dntksemfdj473@gmail.com").build();
		for(int j = 0; j< 100; j++) {
			Item item = Item.builder().itemname("사과").price(2500).description("비타민 C가 풍부합니다.")
				.pictureurl("apple.png").member(member).build();
			i.save(item);
		}
	}
	
	// 데이터 전체 보기 테스트
	//@Test
	public void getAll() {
		List<Item> list = i.findAll();
		System.out.println(list);
	}
	
	// 페이징과 정렬
	//@Test
	public void getPaging() {
		Sort sort = Sort.by("itemid").descending();
		Pageable pageable = PageRequest.of(0, 10);
		Page<Item> list = i.findAll(pageable);
		list.get().forEach(item-> {System.out.println(item);});
	}
	
	// 외래키를 이용한 조회
	//@Test
	public void getFindMember() {
		Member member = Member.builder().email("dntksemfdj473@gmail.com").build();
		List<Item> list = i.findItemByMember(member);
		System.out.println(list);
	}
	
	// 데이터 1개 가져오기
	//@Test
	public void getItem() {
		Optional<Item> item = i.findById(10L);
		if(item.isPresent()) {
			System.out.println(item.get());
		}else {
			System.out.println("데이터가 없습니다.");
		}
	}
	
	// 데이터 수정
	//@Test
	public void updateItem() {
		Member member = Member.builder().email("dntksemfdj473@gmail.com").build();
		Item item = Item.builder().itemid(10L).itemname("아오리사과").description("달고 아삭아삭해요~")
				.price(3450).pictureurl("greenapple.png").member(member).build();
		i.save(item);
	}
	
	// 데이터 삭제
	@Test
	public void deleteItem(){
		Item item = Item.builder().itemid(100L).build();
		i.delete(item);
	}
}
```  

## 7. Service 작업  
### 1) Member 요청을 처리할(파라미터를 받고 결과를 출력) DTO 클래스 생성 - dto.MemberDTO  
```java
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class MemberDTO {
	private String email;
	private String password;
	private String name;
	private String imageurl;
	// 전송된 파일의 내용을 저장할 속성
	private MultipartFile image;
	private LocalDateTime lastlogindate;
	private LocalDateTime regdate;
	private LocalDateTime moddate;
}
```  

### 2) Member 요청을 처리할 메서드의 원형을 가진 인터페이스 생성 - service.MemberService  
```java
public interface MemberService {
	// 데이터 삽입
	public String registerMember(MemberDTO dto);
	public MemberDTO loginMember(MemberDTO dto);
	public MemberDTO getMember(MemberDTO dto);
	public String updateMember(MemberDTO dto);
	public String deleteMember(MemberDTO dto);
	
	// DTO클래스의 객체를 Model클래스의 객체로 변환
	public default Member dtoToEntity(MemberDTO dto) {
		String password = BCrypt.hashpw(dto.getPassword(), BCrypt.gensalt());
		Member member = Member.builder().email(dto.getEmail()).name(dto.getName()).password(password)
				.imageurl(dto.getImageurl()).lastlogindate(dto.getLastlogindate()).build();
		
		return member;
	}
	
	// Model클래스의 객체를 DTO클래스의 객체로 변환
	public default MemberDTO entityToDto(Member member) {
		MemberDTO dto = MemberDTO.builder().email(member.getEmail()).name(member.getName()).imageurl(member.getImageurl())
				.regdate(member.getRegDate()).moddate(member.getModDate()).lastlogindate(member.getLastlogindate()).build();
		return dto;
	}
}
```

### 3) Memeber요청을 처리할 메서드를 구현한 MemberServiceImpl 클래스를 생성하고 작성  
```java
package com.choc.service;

import com.choc.dto.MemberDTO;
import com.choc.model.Member;
import com.choc.persistence.MemberRepository;

import lombok.RequiredArgsConstructor;

import java.util.List;
import java.util.Optional;

import org.mindrot.jbcrypt.BCrypt;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class MemberServiceImpl implements MemberService{
	private final MemberRepository memberRepository;
	
	@Override
	public String registerMember(MemberDTO dto) {
		Member member = dtoToEntity(dto);
		// 이메일 중복체크
		Optional<Member> optional = memberRepository.findById(dto.getEmail());
		if(optional.isPresent()) {
			return "존재하는 이메일";
		}
		// 이름 중복 체크
		List<Member> list = memberRepository.findMemberByName(dto.getName());
		if(list.size() > 0) {
			return "존재하는 이름";
		}
		memberRepository.save(member);
		return member.getEmail();
	}

	@Override
	public MemberDTO loginMember(MemberDTO dto) {
		// 이메일을 가지고 데이터를 찾아옴
		Optional<Member> optional = memberRepository.findById(dto.getEmail());
		
		if(optional.isPresent()) { // 존재하는 이메일
			// 비밀번호 확인
			Member member = optional.get();
			if(BCrypt.checkpw(dto.getPassword(), member.getPassword())) {
				return entityToDto(member);
			}//else {
			//	return null;
			//}
		}//else { // 존재하지 않는 이메일
		//	return null;
		//}
		return null;
	}

	@Override
	public MemberDTO getMember(MemberDTO dto) {
		// 이메일을 가지고 데이터를 찾아옴
		Optional<Member> optional = memberRepository.findById(dto.getEmail());
		
		if(optional.isPresent()) { // 존재하는 이메일
			// 비밀번호 확인
			Member member = optional.get();
			if(BCrypt.checkpw(dto.getPassword(), member.getPassword())) {
				return entityToDto(member);
			}//else {
			//	return null;
			//}
		}
		return null;
	}

	@Override
	public String updateMember(MemberDTO dto) {
		Member member =dtoToEntity(dto);
		memberRepository.save(member);
		return member.getEmail();
	}

	@Override
	public String deleteMember(MemberDTO dto) {
		Member member = dtoToEntity(dto);
		memberRepository.delete(member);
		return member.getEmail();
	}

}
```

### 4) Service 계층을 테스트하기 위한 클래스를 생성하고 작성  
```java
@SpringBootTest
public class ServiceTest {
	@Autowired
	private MemberService m;
	
	// 회원가입 테스트
	//@Test
	public void testRegisterMember() {
		// 처음 추가를 할때는 성공, email과 name이 중복된 데이터면 실패
		MemberDTO dto = MemberDTO.builder().email("youremail@site.com").password("yourpw")
				.name("yourname").imageurl("yourimg.png").build();
		
		String result = m.registerMember(dto);
		System.out.println(result);
	}
	
	// 회원 정보 가져오기
	//@Test
	public void testGetMember() {
		MemberDTO dto = MemberDTO.builder().email("youremail@site.com").build();
		MemberDTO result = m.getMember(dto);
		System.out.println(result);
	}
	
	// 로그인 테스트
	@Test
	public void testLoginMember() {
		MemberDTO dto = MemberDTO.builder().email("youremail@site.com").password("yourpw").build();
		MemberDTO result = m.loginMember(dto);
		System.out.println(result);
		
		// 오늘 날짜를 생성
		Date date = new Date();
		SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");
		String d = sdf.format(date);
		try {
			// true값 주면 같은 이름의 파일에 append
			FileOutputStream fos = new FileOutputStream("C:\\Users\\SAMSUNG\\Desktop\\java\\chocchic.github.io\\react_native\\MobileServer\\"+ d + ".txt", true);
			PrintWriter pw  = new PrintWriter(fos);
			pw.println("내용");
			pw.flush();
			pw.close();
		}catch(Exception e) {
			
		}
	}
	
	// 멤버 수정 테스트
	//@Test
	public void updateMember() {
		MemberDTO dto = MemberDTO.builder().email("youremail@site.com").name("NAME").password("pw1234")
				.imageurl("user.png").build();
		String result = m.updateMember(dto);
		System.out.println(result);
	}
	
	// 멤버 삭제 테스트
	@Test
	public void deleteMember() {
		MemberDTO dto = MemberDTO.builder().email("youremail@site.com").build();
		String result = m.deleteMember(dto);
		System.out.println(result);
	}
}
```  

### 5) ItemEntity를 Controller나 Service에서 사용하기 위한 ItemDTO클래스를 생성하고 작성  
```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ItemDTO {
	private Long itemid;
	private String itemname;
	private Integer price;
	private String description;
	// 업로드된 이미지 경로를 저장
	private String pictureurl;
	// 파일을 받아오기 위한 변수
	private MultipartFile image;
	// Entity를 만들 때는 Entity를 외래키로 추가하지만 화면 입출력할 때는 필요한 데이터만 선언  
	private String email;
}
```  

### 6) 페이지 단위 요청을 위한 DTO - dto/PageRequestDTO  
```java
@Data
@Builder
@AllArgsConstructor
public class PageRequestItemDTO {
	// 페이지 번호 - 1부터 시작
	private int page;
	// 한 페이지에 보여질 데이터 개수
	private int size;
	// 특정 항목으로 조회하고자 하는 경우
	//private String condition;
	//private String keyword;
	
	// 생성자
	public PageRequestItemDTO() {
		page = 1;
		size =10;
	}
	// 페이지 번호와 데이터 개수를 가지고 Pageable 객체를 생성해주는 메서드
	public Pageable getPageable(Sort sort) {
		// JPA에서는 페이지번호가 0부터 시작하기 때문에 page-1을 해주어야 뷰에서는 1부터 시작하고, DB에서는 0부터 페이징가능
		return PageRequest.of(page-1,size,sort);
	}
}
```  

### 7) 페이지단위로 출력을 하기 위한 DTO - dto/PageResponseItemDTO  
```java
@Data
public class PageResponseItemDTO {
	// Dto 리스트
	private List<Item> itemList;
	
	// 전체 페이지 개수
	private int totalPage;
	// 현재 페이지 번호
	private int page;
	
	// 페이지 번호 목록 크기
	private int size;
	// 출력할 페이지 번호 시작과 종료
	private int start, end;
	
	// 이전과 다음 여부
	private boolean prev,next;
	//페이지 번호 목록
	private List<Integer> pageList;
	
	// 페이지 번호 목록을 만들어주는 메서드
	public void makePageList(Pageable pageable) {
		page = pageable.getPageNumber()+1;
		size = pageable.getPageSize();
		
		int tempEnd = (int)(Math.ceil(page/10.0))*10;
		start = tempEnd - 9;
		prev = start > 1;
		end = totalPage > tempEnd ? tempEnd : totalPage;
		next = tempEnd < totalPage;
		pageList = IntStream.rangeClosed(start, end).boxed().collect(Collectors.toList());
	}
	
}
```  

### 8) Item 요청을 처리할 메서드의 원형을 가진 서비스 인터페이스를 생성 - service/ItemService
```java
public interface ItemService {
	// 아이템 등록
	public Long registerItem(ItemDTO dto);
	// 하나의 아이템 가져오기
	public ItemDTO getItem(ItemDTO dto);
	// 아이템 수정
	public Long updateItem(ItemDTO dto);
	// 아이템 삭제
	public Long deleteItem(ItemDTO dto);
	
	// 페이지 단위로 데이터가져오기
	public PageResponseItemDTO getList(PageRequestItemDTO dto);
	
	// DTO를 Entity로 변환해주는 메서드
	public default Item dtoToEntity(ItemDTO dto) {
		Item item = Item.builder().itemid(dto.getItemid()).itemname(dto.getItemname()).price(dto.getPrice())
				.description(dto.getDescription()).pictureurl(dto.getPictureurl())
				.member(Member.builder().email(dto.getEmail()).build()).build();
		return item;
	}
	
	// Entity를 DTO로 변환해주는 메서드
	public default ItemDTO entitytoDto(Item item) {
		ItemDTO dto = ItemDTO.builder().itemid(item.getItemid()).itemname(item.getItemname()).price(item.getPrice())
				.description(item.getDescription()).pictureurl(item.getPictureurl()).email(item.getMember().getEmail()).build();
		return dto;
	}
}
```  

### 9) Item에 대한 요청을 처리하는 메서드를 구현할 ServiceImpl클래스를 생성하고 메서드 구현  
```java
@Service
@RequiredArgsConstructor
public class ItemServiceImpl implements ItemService{
	private final ItemRepository itemRepository;
	
	@Override
	public Long registerItem(ItemDTO dto) {
		Item item = dtoToEntity(dto);
		itemRepository.save(item);
		return item.getItemid();
	}

	@Override
	public ItemDTO getItem(ItemDTO dto) {
		Long itemid = dto.getItemid();
		Optional<Item> op = itemRepository.findById(itemid);
		if(op.isPresent()) {
			return entitytoDto(op.get());
		}
		return null;
	}

	@Override
	public Long updateItem(ItemDTO dto) {
		Item item = dtoToEntity(dto);
		Long itemid = item.getItemid();
		itemRepository.save(item);
		return itemid;
	}

	@Override
	public Long deleteItem(ItemDTO dto) {
		Item item = dtoToEntity(dto);
		Long itemid = item.getItemid();
		itemRepository.deleteById(itemid);
		return itemid;
	}

	@Override
	public PageResponseItemDTO getList(PageRequestItemDTO dto) {
		Sort sort = Sort.by("itemid").descending();
		Pageable pageable = PageRequest.of(dto.getPage()-1, dto.getSize(), sort);
		Page<Item> page = itemRepository.findAll(pageable);
		PageResponseItemDTO result = new PageResponseItemDTO();
		result.makePageList(pageable);
		result.setTotalPage(page.getTotalPages());
		List<Item> list = new ArrayList<>();
		page.get().forEach(item -> {
			list.add(item);
		});
		result.setItemList(list);
		return null;
	}

}
```  

### 10) Test클래스에서 테스트  
```java
@SpringBootTest
public class ServiceTest {
// ... 생략 ...
	
	@Autowired
	private ItemService itemService;
	
	// 데이터 삽입
	//@Test
	public void testregisterItem() {
		for(int i = 0; i<100; i++) {
			ItemDTO dto = ItemDTO.builder().itemname("apple_"+i).price(3000).description("사과_"+i).pictureurl("apple_"+i+".png")
					.email("dntksemfdj473@gmail.com").build();
			Long itemid = itemService.registerItem(dto);
			System.out.println(itemid);
		}
	}
	// 데이터 1개 가져오기
	//@Test
	public void testGetItem() {
		ItemDTO dto = ItemDTO.builder().itemid(101L).build();
		System.out.println(itemService.getItem(dto));
	}
	
	// 페이지 단위로 가져오기
	//@Test
	public void testGetList() {
		PageRequestItemDTO dto = PageRequestItemDTO.builder().page(2).size(10).build();
		PageResponseItemDTO result = itemService.getList(dto);
		System.out.println(result);
	}
	
	// 데이터 수정
	//@Test
	public void testUpdateItem() {
		ItemDTO dto = ItemDTO.builder().itemid(16L).itemname("apple_0616수정").price(6000).description("수정된 사과")
				.pictureurl("apple__0616수정")
				.email("dntksemfdj473@gmail.com").build();
		Long itemid = itemService.updateItem(dto);
		System.out.println(itemid);
	}
	
	// Item 삭제
	@Test
	public void testDeleteItem() {
		ItemDTO dto = ItemDTO.builder().itemid(23L).build();
		Long itemid = itemService.deleteItem(dto);
		System.out.println(itemid);
	}
}
```  
## 8. 파일 업로드 처리를 위한 설정
* 실제 제품을 만들어서 배포할 때는 이 부부은 다시 수정됩니다.  
코드가 수정되는 것은 아니고 파일 업로드 위치를 수정합니다.  
운영환경에서는 역할별로 컴퓨터를 물리적으로 분할하는 것이 일반적입니다.  
데이터베이스, 애플리케이션, 파일 저장소 등을 물리적으로 분할합니다.  

* 파일 저장소를 설정하는 방법도 예전에는 별도의 파일 서버를 이용했지만 최근에는 클라우드를 많이 이용합니다.  

* 개발자나 서비스를 구현하고자 하는 경우네는 요즈음같은 경우는 기본적인클라우드 사용법을 먼저 익히는 것이 좋습니다. 파일 서버 활용이나 데이터베이스 서버 그리고 운영환경을 만드는 부분을 공부해 두는 것이 좋습니다.  
우리나라의 경우 중소기업이나 중견기업의 경우 AWS를 압도적으로 많이 사용합니다.  
대기엽의 경우는 마이크로소프트의 애저 서비스도 이용합니다.

### 1) 업로드된 파일을 저장할 위치를 결정  

### 2) application.properties파일에 파일 업로드 관련 설정 추가  
```ini
# 파일 업로드 관련 설정
spring.servlet.multipart.enabled=true
spring.servlet.multipart.location=C:\\Users\\SAMSUNG\\Documents\\data
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=30MB

# 환경의 변화가 생겼을 떄 수정할 정적 상수를 속성으로 생성
com.choc.upload.path=C:\\Users\\SAMSUNG\\Documents\\data
```  

* +) 개발환경과 운영환경을 분리한 경우에는 개발 환경에서 운영환경으로 이전할 때(이행 - Migration) 변경될 가능성이 있는 텍스트 정보(데이터베이스 접속 위치, 파일 업로드 경로 등)는 별도의 텍스트 파일이나 데이터베이스에 보관하는 것이 좋습니다.  
내용이 변경되더라도 소스 코드를 수정하지 않고 적용을 할 수 있습니다.  
모바일에서는 documents디렉터리 이용하는 부분을 생각해봐야 합니다.  

## 9. Member요청 처리 작업  
### 1)기본 준비 작업
* 삽입, 삭제, 갱신 요청에 대한 응답을 위한 클래스를 생성 - ResponseMemberDTO: MemberDTO에 error 속성만 수정해도 됨
```java
@Builder
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ResponseMemberDTO {
	private String error;
	private String email;
	private String password;
	private String name;
	private String imageurl;
	private LocalDateTime lastlogindate;
	private LocalDateTime regdate;
	private LocalDateTime moddate;
}
``` 

* Member 요청을 처리할 MemberController를 생성하고 기본적인 구조를 생성  
```java
@RestController
@RequestMapping("member")
public class MemberController {
	@Autowired
	private MemberService memberService;
}
```  

### 2)데이터 삽입(회원 가입 처리)  
* MemberServiceImpl 클래스에 파일 업로드 경로를 가져오기 위한 속성을 추가  
```java
	//application.properties 파일에 작성한 속성 가져오기
	@Value("${com.adamsoft.upload.path}")
	private String uploadPath;
```  

* MemberServiceImpl 클래스에 이미지 파일이 업로드 될 디렉토리를 생성해주는 메서드를 생성  
```java
	//업로드한 날짜 별로 이미지를 저장하기 위해서 날짜별로 디렉토리를 만들어서 경로를 리턴하는 메서드
	private String makeFolder() {
		//오늘 날짜를 문자열로 생성
		String str = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy/MM/dd"));
		//문자열을 치환 - /를 운영체제의 디렉토리 구분자로 치환
		String realUploadPath = str.replace("//", File.separator);
		//디렉토리 생성
		File uploadPathDir = new File(uploadPath, realUploadPath);
		if(uploadPathDir.exists() == false) {
			uploadPathDir.mkdirs();
		}
		return realUploadPath;
		
	}
```  

* MemberServiceImpl 클래스에 파일 업로드를 처리하기 위해서 데이터 삽입 요청 처리 메서드를 수정  
```java
	@Override
	public String registerMember(MemberDTO dto) {
		Member member = dtoToEntity(dto);
		//이메일 중복 체크 - 별도로 구성할 수 있음
		Optional<Member> optional = memberRepository.findById(dto.getEmail());
		if(optional.isPresent()) {
			return "존재하는 이메일";
		}
		
		//이름 중복 체크 - 별도로 구성할 수 있음
		List<Member> list = memberRepository.findMemberByName(dto.getName());
		if(list.size() > 0) {
			return "존재하는 이름";
		}
		
		//파일 업로드 처리
		//전송 받은 파일을 가져오기
		MultipartFile uploadFile = dto.getImage();
		//전송된 파일이 있다면
		if(uploadFile.isEmpty() == false) {
			//이미지 파일 만 업로드하기 위해서 이미지 파일이 아니면 작업 중단
			if(uploadFile.getContentType().startsWith("image") == false) {
				return null;
			}
			//원본 파일의 파일 이름 찾아오기
			String originalName = uploadFile.getOriginalFilename();
			String fileName = originalName.substring(originalName.lastIndexOf("\\") + 1);
			
			//파일을 업로드할 디렉토리 경로를 생성
			String realUploadPath = makeFolder();
			
			//업로드 할 파일의 경로를 생성
			String uuid = UUID.randomUUID().toString(); //파일 이름의 중복을 피하기 위해서 생성
			String saveName = uploadPath + File.separator + 
					realUploadPath + File.separator + uuid + fileName;
			Path savePath = Paths.get(saveName);
			try {
				//파일 업로드
				uploadFile.transferTo(savePath);
			}catch(Exception e) {
				System.out.println(e.getLocalizedMessage());
			}
			//이미지 경로를 DTO에 설정
			dto.setImageurl(realUploadPath + File.separator + uuid + fileName);
		}
		member = dtoToEntity(dto);
		memberRepository.save(member);
		return member.getEmail();
	}
```  

* MemberController 클래스에 회원 가입 요청을 처리하는 메서드를 작성  
```java
	@PostMapping("/register")
	public ResponseEntity<?> registerMember(MemberDTO dto){
		ResponseMemberDTO response = null;
		try {
			//데이터 삽입 처리
			String email = memberService.registerMember(dto);
			response = ResponseMemberDTO.builder().email(email).build();
		}catch(Exception e) {
			String error = e.getMessage();
			response = ResponseMemberDTO.builder().error(error).build();
		}
		return ResponseEntity.ok().body(response);
	}
```  

* PostMan을 이용해서 테스트: RestController는 출력되는 화면이 없기 때문에 PostMan 같은 도구를 이용해서 테스트  

### 3) 로그인 처리  
* MemberController클래스에 로그인 요청을 처리하는 메서드 생성  
```java
	@PostMapping("/login")
	public ResponseEntity<?> loginMember(MemberDTO dto){
		ResponseMemberDTO response = null;
		try {
			//로그인 처리
			MemberDTO result = memberService.loginMemer(dto);
			if(result == null) {
				response = ResponseMemberDTO.builder()
						.error("없는 이메일이나 잘못된 비밀번호입니다.").build();
			}else {
				response = ResponseMemberDTO.builder()
						.email(result.getEmail())
						.name(result.getName())
						.imageurl(result.getImageurl())
						.regdate(result.getRegdate())
						.moddate(result.getModdate())
						.lastlogindate(result.getLastlogindate())
						.build();
			}
		}catch(Exception e) {
			String error = e.getMessage();
			response = ResponseMemberDTO.builder().error(error).build();
		}
		return ResponseEntity.ok().body(response);
	}
```

### 4) 회원 정보 가져오기  
* 회원 정보를 가져오는 메서드를 MemberController 클래스에 생성  
```java
	@GetMapping("/get")
	public ResponseEntity<?> getMember(MemberDTO dto){
		ResponseMemberDTO response = null;
		try {
			//회원 정보 가져오기
			MemberDTO result = memberService.getMemer(dto);
			if(result == null) {
				response = ResponseMemberDTO.builder()
						.error("없는 이메일입니다.").build();
			}else {
				response = ResponseMemberDTO.builder()
						.email(result.getEmail())
						.name(result.getName())
						.imageurl(result.getImageurl())
						.regdate(result.getRegdate())
						.moddate(result.getModdate())
						.lastlogindate(result.getLastlogindate())
						.build();
			}
		}catch(Exception e) {
			String error = e.getMessage();
			response = ResponseMemberDTO.builder().error(error).build();
		}
		return ResponseEntity.ok().body(response);
	}
```

### 5) 회원 정보 수정  
* MemberServiceImpl 클래스의 회원 정보 수정 메서드를 수정  
```java
	@Override
	public String updateMember(MemberDTO dto) {
		//전송된 이미지를 확인
		MultipartFile uploadFile = dto.getImage();
		//전송된 이미지가 있다면 파일 업로드
		if(dto.getImage().isEmpty() == false) {
			//이미지 파일 만 업로드하기 위해서 이미지 파일이 아니면 작업 중단
			if(uploadFile.getContentType().startsWith("image") == false) {
				return null;
			}
			//원본 파일의 파일 이름 찾아오기
			String originalName = uploadFile.getOriginalFilename();
			String fileName = originalName.substring(originalName.lastIndexOf("\\") + 1);
			
			//파일을 업로드할 디렉토리 경로를 생성
			String realUploadPath = makeFolder();
			
			//업로드 할 파일의 경로를 생성
			String uuid = UUID.randomUUID().toString(); //파일 이름의 중복을 피하기 위해서 생성
			String saveName = uploadPath + File.separator + 
					realUploadPath + File.separator + uuid + fileName;
			Path savePath = Paths.get(saveName);
			try {
				//파일 업로드
				uploadFile.transferTo(savePath);
			}catch(Exception e) {
				System.out.println(e.getLocalizedMessage());
			}
			//이미지 경로를 DTO에 설정
			dto.setImageurl(realUploadPath + File.separator + uuid + fileName);
		}else {
			//전송된 이미지가 없다면 이전 이미지 사용
			dto.setImageurl(getMemer(dto).getImageurl());
		}
		
		Member member = dtoToEntity(dto);
		memberRepository.save(member);
		return member.getEmail();
	}
```  

* MemberController 클래스에 데이터 수정 요청을 처리하는 메서드를 작성  
```java
	@PostMapping("/update")
	public ResponseEntity<?> updateMember(MemberDTO dto){
		ResponseMemberDTO response = null;
		try {
			//데이터 수정 처리
			String email = memberService.updateMember(dto);
			response = ResponseMemberDTO.builder().email(email).build();
		}catch(Exception e) {
			String error = e.getMessage();
			response = ResponseMemberDTO.builder().error(error).build();
		}
		return ResponseEntity.ok().body(response);
	}
```  

### 6) 회원 정보 삭제  
* MemberController 클래스에 한 명의 회원 정보를 삭제하는 메서드를 작성  
```java
	@PostMapping("/delete")
	public ResponseEntity<?> deleteMember(MemberDTO dto){
		ResponseMemberDTO response = null;
		try {
			//데이터 삭제 처리
			String email = memberService.deleteMember(dto);
			response = ResponseMemberDTO.builder().email(email).build();
		}catch(Exception e) {
			String error = e.getMessage();
			response = ResponseMemberDTO.builder().error(error).build();
		}
		return ResponseEntity.ok().body(response);
	}
```  

### 7) 파일 다운로드  
* MemberService 인터페이스에 파일 다운로드를 위한 메서드를 선언  
```java
public ResponseEntity<Object> download(String path);
```  

* MemberServiceImpl 클래스에 파일 다운로드를 위한 메서드를 구현  
```java
@Override
	public ResponseEntity<Object> download(String path) {
		try {
			//다운로드 받을 파일 경로를 생성
			Path filePath = Paths.get(uploadPath + File.separator + path);
			//파일 resource 가져오기
			Resource resource = 
					new InputStreamResource(
							Files.newInputStream(filePath));
			//파일 정보를 헤더에 등록
			File file = new File(path);
			HttpHeaders headers = new HttpHeaders();
			headers.setContentDisposition(
					ContentDisposition.builder("attachment")
					.filename(file.getName())
					.build());
			return new ResponseEntity<Object>(
					resource, headers, HttpStatus.OK);
			
		}catch(Exception e) {
			return new ResponseEntity<Object>(null, HttpStatus.CONFLICT);
		}
	}
```  

* MemberController 클래스에 다운로드 요청을 처리하는 메서드를 구현  
```java
	@GetMapping("/download")
	public ResponseEntity<Object> download(String path){
		return memberService.download(path);
	}
```  

## 10. Item 요청 처리 작업  
### 1) 기본 준비 작업 
* ItemDTO 클래스에 에러 메시지를 저장할 error 속성을 추가  
```java
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class PageResponseItemDTO {
	private String error;
	
	//DTO 리스트
	private List<ItemDTO> itemList;
	
	//전체 페이지 개수
	private int totalPage;
	
	//현재 페이지 번호
	private int page;
	
	//페이지 번호 목록 크기
	private int size;
	//출력할 페이지 번호 시작 과 종료
	private int start, end;
	//이전 과 다음 여부
	private boolean prev, next;
	//페이지 번호 목록
	private List<Integer> pageList;
	
	//페이지 번호 목록을 만들어주는 메서드
	public void makePageList(Pageable pageable) {
		page = pageable.getPageNumber() + 1;
		size = pageable.getPageSize();
		
		int tempEnd = (int)(Math.ceil(page/10.0)) * 10;
		start = tempEnd - 9;
		prev = start > 1;
		end = totalPage > tempEnd ? tempEnd : totalPage;
		next = totalPage > tempEnd;
		pageList = IntStream.rangeClosed(start, end)
				.boxed().collect(Collectors.toList());
	}	
}
```  

* PageResponseItemDTO 클래스를 수정 - Entity 클래스는 JSON으로 출력할 수 없으므로 Item 클래스를 ItemDTO 클래스로 변환  
```java
@Data
public class PageResponseItemDTO {
	private String error;
	
	//DTO 리스트
	private List<ItemDTO> itemList;
```  

* ItemControllerClass를 생성하고 기본 코드를 작성  
```java
@RestController
@RequestMapping("item")
@RequiredArgsConstructor
public class ItemController {
	private final ItemService itemService;
}
```  

* ItemServiceImpl 클래스에 요청을 처리하기 위한 속성 과 메서드 추가  
```java
	//application.properties 파일에 작성한 속성 가져오기
	@Value("${com.adamsoft.upload.path}")
	private String uploadPath;

	//업로드한 날짜 별로 이미지를 저장하기 위해서 날짜별로 디렉토리를 만들어서 경로를 리턴하는 메서드
	private String makeFolder() {
		//오늘 날짜를 문자열로 생성
		String str = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy/MM/dd"));
		//문자열을 치환 - /를 운영체제의 디렉토리 구분자로 치환
		String realUploadPath = str.replace("//", File.separator);
		//디렉토리 생성
		File uploadPathDir = new File(uploadPath, realUploadPath);
		if(uploadPathDir.exists() == false) {
			uploadPathDir.mkdirs();
		}
		return realUploadPath;
		
	}

	//삽입이나 수정 그리고 삭제시 작업 시간을 기록하는 메서드
	//이 시간을 읽어서 데이터가 변경되었는지 확인
	private void updateDate() {
		try(PrintWriter pw = new PrintWriter(
				new FileOutputStream("./updatedate.dat"))){
			//현재 날짜 및 시간 가져오기
			String str = LocalDateTime.now().format(
					DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
			pw.println(str);
			pw.flush();
		}catch(Exception e) {
			System.out.println(e.getLocalizedMessage());
		}
	}
```  

### 2) 페이지 단위로 데이터 가져오기  
* ItemServiceImpl 클래스이 요청 처리 메서드 수정  
```java
	@Override
	public PageResponseItemDTO getList(PageRequestItemDTO dto) {
		Sort sort = Sort.by("itemid").descending();
		Pageable pageable = PageRequest.of(
				dto.getPage()-1, dto.getSize(), sort);
		Page<Item> page = itemRepository.findAll(pageable);
		
		PageResponseItemDTO result = new PageResponseItemDTO();
		result.makePageList(pageable);
		result.setTotalPage(page.getTotalPages());
		List<ItemDTO> list = new ArrayList<>();
		page.get().forEach(item -> {
			list.add(entityToDto(item));
		});
		result.setItemList(list);
		return result;
	}
```  

* ItemController 클래스에 페이지 단위 요청을 처리하는 메서드를 구현  
```javva
	//페이지 단위로 데이터 가져오기
	@GetMapping("list")
	public ResponseEntity<?> getList(PageRequestItemDTO dto){
		PageResponseItemDTO response = null;
		try {
			response = itemService.getList(dto);
		}catch(Exception e) {
			response = new PageResponseItemDTO();
			response.setError(e.getMessage());
		}
		return ResponseEntity.ok().body(response);
	}
```  

### 3) 데이터 삽입 요청 처리  
* ItemServiceImpl 클래스에서 데이터 삽입을 처리하는 메서드를 수정  
```java
	@Override
	public Long registerItem(ItemDTO dto) {
		//파일 업로드 처리
		//전송 받은 파일을 가져오기
		MultipartFile uploadFile = dto.getImage();
		//전송된 파일이 있다면
		if(uploadFile.isEmpty() == false) {
			//이미지 파일 만 업로드하기 위해서 이미지 파일이 아니면 작업 중단
			if(uploadFile.getContentType().startsWith("image") == false) {
				return null;
			}
			//원본 파일의 파일 이름 찾아오기
			String originalName = uploadFile.getOriginalFilename();
			String fileName = originalName.substring(originalName.lastIndexOf("\\") + 1);
			
			//파일을 업로드할 디렉토리 경로를 생성
			String realUploadPath = makeFolder();
			
			//업로드 할 파일의 경로를 생성
			String uuid = UUID.randomUUID().toString(); //파일 이름의 중복을 피하기 위해서 생성
			String saveName = uploadPath + File.separator + 
					realUploadPath + File.separator + uuid + fileName;
			Path savePath = Paths.get(saveName);
			try {
				//파일 업로드
				uploadFile.transferTo(savePath);
			}catch(Exception e) {
				System.out.println(e.getLocalizedMessage());
			}
			//이미지 경로를 DTO에 설정
			dto.setPictureurl(realUploadPath + File.separator + uuid + fileName);
		}
		
		Item item = dtoToEntity(dto);
		itemRepository.save(item);
		//수정한 시간을 기록
		updateDate();
		return item.getItemid();
	}
```  

* ItemController 클래스에 데이터 삽입 요청을 처리하는 메서드를 생성  
```java
	//데이터 삽입
	@PostMapping("register")
	public ResponseEntity<?> registerItem(ItemDTO dto){
		ItemDTO response = null;
		try {
			Long itemid = itemService.registerItem(dto);
			response = ItemDTO.builder().itemid(itemid).build();
		}catch(Exception e) {
			response = ItemDTO.builder().error(e.getMessage()).build();
		}
		
		return ResponseEntity.ok().body(response);
	}
```  	

### 4) 데이터 1개 가져오기  
* ItemController 클래스에 데이터 1개를 가져오는 메서드를 구현  
```java
	//데이터 1개 가져오기
	@GetMapping("get")
	public ResponseEntity<?> getItem(ItemDTO dto){
		ItemDTO response = null;
		try {
			response = itemService.getItem(dto);
		}catch(Exception e) {
			response = ItemDTO.builder().error(e.getMessage()).build();
		}
		
		return ResponseEntity.ok().body(response);
	}
```  

### 5) 데이터 삭제  
* ItemServiceImpl 클래스의 데이터 삭제 메서드 수정  
```java
	@Override
	public Long deleteItem(ItemDTO dto) {
		Item item = dtoToEntity(dto);
		Long itemid = item.getItemid();
		itemRepository.deleteById(itemid);
		updateDate();
		return itemid;
	}
``` 

* ItemController 클래스에 데이터 삭제 요청 처리 메서드 작성  
```java
	//데이터 삭제
	@PostMapping("delete")
	public ResponseEntity<?> deleteItem(ItemDTO dto){
		ItemDTO response = null;
		try {
			Long itemid = itemService.deleteItem(dto);
			response = ItemDTO.builder().itemid(itemid).build();
		}catch(Exception e) {
			response = ItemDTO.builder().error(e.getMessage()).build();
		}
		
		return ResponseEntity.ok().body(response);
	}
```  

### +) 엔지니어링 방식  
* Forward Engineering  

* Reverse Engineering  

### 6) 데이터 수정
* ItemServiceImpl 클래스의 데이터 수정을 위한 메서드 수정  
```java
@Override
	public Long updateItem(ItemDTO dto) {
		// 삽입할 때는 이미지가 없으면 이미지 업로드를 처리하지 않거나 기본 이미지로 설정
		// 수정을 할 때 이미지가 없다는 것은 수정할 이미지가 없다는 의미가 될 수 있음
		if(dto.getImage().isEmpty() == false) {
			// 업로드된 파일을 가져오기
			MultipartFile uploadFile = dto.getImage();
			
			// 원본 파일 이름 찾아오기
			String originalName = uploadFile.getOriginalFilename();
			// IE나 Edge에서는 전체 파일 경로가 오기 때문에 마지막 \위치를 찾아서 뒷부부만 가져와야 합.
			String fileName = originalName.substring(originalName.lastIndexOf("\\")+1); // 모바일에서 이 작업은 안해도 됨
			
			// 업로드할 디렉터리 경로를 생성, 회원 정보 이미지와 아이템 이미지를 구별해서 ㅅ저장하고자 하면 makeFolder 메서드를 각ㄱ각 구현
			String realUploadPath = makeFolder();

			// 파일 이름 중복을 최소화하기 위한 UUID 생성
			String uuid = UUID.randomUUID().toString();
			// 파일 이름 중간에 _를 이용해서 구분
			// 교재나 검색한 소스가 보일 때 \나 /가 보이면 앞뒤 문맥을 읽어서 디렉터리 기호라면 File.separator로 변경하는 것을 고려
			// 고재를 볼 때는 어떤 운영체제에서 작성한 것인지 확인하고 교재를 읽어보는 것이 좋습니다. 
			String saveName = uploadPath + File.separator + realUploadPath + File.separator + uuid + fileName;
			// 실제 전송할 경로를 생성 - jdk 1.7 이상에서 지원
			Path savePath = Paths.get(saveName);
			
			try {
				// 파일 전송
				uploadFile.transferTo(savePath);
			}catch(Exception e) {
				System.out.println(e.getLocalizedMessage());
				e.printStackTrace();
			}
			// 파일의 경로를 저장
			dto.setPictureurl(realUploadPath + File.separator + uuid + fileName);
		}else {
			// 업로드할 파일이 없을 때 이전 내용을 그대로 적용
			dto.setPictureurl(getItem(dto).getPictureurl());
		}
		
		// 데이터베이스에서 수정
		Item item = dtoToEntity(dto);
		Long itemid = item.getItemid();
		itemRepository.save(item);
		// 수정한 날짜 업데이트
		updateDate();
		return itemid;
	}
```  

* +) IOT 분야에서 대부분의 경우는 Linux 기반의 운영체제를 많이 사용합니다.  
의료기기같은 분야에서는 Windows도 많이 사용합니다.  
개발할 때 운영환경과 개발환경이 다를 수 있음을 항상 기억하기.  
Java의 가장 큰 장점 : WORA(Write Once Run Anywhere), 플랫폼 독립적 

* ItemController클래스에 데이터를 수정하는 요청을 처리하는 메서드 생성  
```java
// 데이터 수정
	@PostMapping("update")
	public ResponseEntity<?> updateItem(ItemDTO dto){
		ItemDTO response = null;
		try {
			Long itemid = itemService.updateItem(dto);
			response = ItemDTO.builder().itemid(itemid).build();
		}catch (Exception e) {
			response = ItemDTO.builder().error(e.getMessage()).build();
		}
		return ResponseEntity.ok().body(response);
	}
```  

* PostMan으로 테스트

* +) 데이터베이스 제약조건  
	Constraint(제약조건) : 데이터를 안전하게 보호하기 위해서 지켜야할 조건  
	개체 무결성 제약조건(Entity Integerity Constraint) : 기본키는 null이거나 중복될 수 없다.  
	참조 무결성 제약조건(Referential Integrity Constraint) : 외래키는 참조할 수없는 값을 가질 수 없다. 외래키 값은 참조하는 테이블에 존재하는 값이나 null이어야 한다.  

	UNIQUE  
	NOT NULL  
	CHECK(도메인 제약 조건) - @Valid를 이용해서 Spring에서는 검사가 가능합니다. 유효성 것마를 하고자 할 때는 반드시 정규 표현식을 조금 학습하셔야 합니다.  

 * +) QA : 테스트와 품질 관리
	black box test : 기능을 검사, equivalence partitioning 기능이 제대로 동작하는 상황과 그렇지 않은 상황을 동등하게 테스트  

	white box test : 내부 구조를 검사 - 반복문이나 분기문등을 검사  

	알파테스트 : 개발자의 환경에서 제대로 동작하는지 코드를 테스트  
	베타테스트 : 사용자의 환경에서 제대로 동작하는지 코드를 테스트  

### 7) 마지막 업데이트 된 시간 저장  
* +) 최근의 프로그래밍에서는 Edge Computing이 매우 중요하게 취급됩니다. 데이터 발생지에서 직접 처리하는 방식입니다.  

	실제 서비스에서는 트래픽을 어떻게 최소화하는지에 대한 부분도 중요합니다.  
	클라이언트 - 서버 방식의 애플리케이션에서는 아주 중요한 부분 중의 하나입니다.  
	클라이언트에 일정 부분의 데이터를 저장하고 데이터가 변경된 경우에만 다운로드받아서 사용하는 방식을 많이 구현합니다.  
	이런 방식의 구현을 할 때 서버의 데이터와 클라이언트가 로컬에 소유하고 있는 데이터와 다른지 구별을 해야 하는데, 이 방식 중의 하나가 서버에는 데이터가 변경된 시간을저장해두고 클라이언트에게 전송할 수 있도록 하는 것이고, 클라이언트에서는 무조건 데이터를 다운로드 받는 것이 아니고 자신에게 저장된 마지막 다운로드 시간과 서버의 마지막 업데이트 시간을 비교해서 데이터를 업데이트하는 것입니다.  
	이렇게 구현을 하면 클라이언트의 네트워크가 되지 않는 상황에서도 로컬에 저장된 데이터를 사용할 수 있습니다.  

	드물기는 하지만 파일의 크기를 가지고 비교하는 경우도 있습니다.  

* ItemService인터페이스에 마지막 수정시간을 전송하는 메서드를 선언  
```java
	// 마지막 업데이트된 시간을 전송하는 메서드  
	public String updatedate();
```  

* ItemServiceImpl클래스에 마지막 수정 시간을 전송하는 메서드를 구현  
```java
	@Override
	public String updatedate() {
		try(BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream("./updatedate.dat")))){
			String str = br.readLine();
			return str;
			// return br.readLine();
		}catch(Exception e) {
			System.out.println(e.getLocalizedMessage());
			return null;
		}
	}
```  

### +) 앱 개발 방법  
* Native app 개발을 위한 IDE에서 개발
	Android Studio나 Xcode에서 개발, 여러 종류의 애플리케이션을 만들려면 여러 언어를 습득해야 한다는 단점이 있지만 스마트 디바이스의 모든 API를 전부 사용할 수 있으며 디버깅이 쉽고, 많은 개발 문서를 지원

* 하이브리드 앱 개발  
	Android Studio나 XCode가 아닌 다른 방법을 이용해서 2가지 종류 이상의 운영체제에서 동작하는 애플리케이션을 동시에 개발하는 방법  
	react-native(javascript 기반 - typescript와 react의 선행 필요), flutter(Dart 기반)
	단점 : 프레임워크 업데이트가 자주 발생하기 때문에 개발이 어려워질 수 있지만 빠르게 여러 종류의 애플리케이션을 만들 수 있다는 장점이 있음  

* Mobile Web 개발
	Mobile Web 애플리케이션을 구축하고 스마트 디바이스의 브라우저에서 접속하던가 스마트 디바이스에 Web View를 배치하고 Mobile Web에 접속하는 방법, 최근에는 Web View만으로 구성된 애플리케이션은 마켓에서 reject됩니다.  

## 9. SmartPhone Application 제작 - Android  
### 1) Android Studio에서 프로젝트를 생성  

* 화면 구성 단위  
Android : Activity -> Fragment -> View -> Layer(거의 사용하지 않음)  
iOS : ViewController -> View -> Layer  
react : Compnent

* 화면 작업 방법  
Android : XML과 java(kt)파일이 하나의 쌍으로 존재해서 XML파일에 디자인을 하고 java파일에서 불러서 사용하는 방식을 많이 이용. XML없이도 가능  
iOS : Storyboard를 이용 가능, Interface Builder를 이용해서 XML로 생성한 후 swift파일에서 불러서 사용, 최근에는 Swift UI라고 해서 새로운 방식으로 디자인 하기도 함.
react : JSX문법으로 화면을 디자인  

* 리소스 관리
Android : 리소스와 코드를 엄격하게 구분하고 리소스를 저장하는 디렉터리의 이름이 용도를 결정하는 경우가 많음. 리소스를 하나의 정수형 상수로 변환해서 사용할 수 있도록 하기 때문  
iOS,react : 리소스를 소스코드와 구별하지 않음.  

### 2) 인터넷 권한 설정  
* 준비 작업
서버의 데이터를 사용하기 위해서는 인터넷 권한을 설정해야 함  
서버의 프로토콜이 http인 경우는 별도의 설정을 추가해야 합니다.  
iOS의 경우는 인터넷 권한은 기본적으로 주어지지만 http에 접속하는 경우는 역시 별도의 수정이 추가되어야 합니다.  

* AndroidManifest.xml 파일을 수정  
```xml
    <!-- 인터넷 권한 추가 -->
    <uses-permission android:name="android.permission.INTERNET"/>
```

### 3) 페이지단위로 데이터 가져오기 구현  
* 1. 화면 디자인을 수정 - res/layout/main_activity.xml파일을 수정  
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity"
    android:orientation="horizontal">

    <TextView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:text="ITEM LIST"
        android:textSize="32sp"
        android:gravity="center"
        android:background="@color/teal_200"
         />
    <ProgressBar
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:id="@+id/downloadview"
        />

    <ListView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:id="@+id/listview"
        />

</LinearLayout>
```  

* +) 안드로이드에서 뷰의 종류  
	Layout : 여러 개의 뷰를 모아놓은 뷰이며 Adapter클래스와 연동해서 데이터를 출력하는 뷰도 layout에 속함  

	Layout이 없는 뷰  

* 하나의 데이터를 표현하기 위한 클래스 생성 - item.java
```java
package com.chocchic;

import java.io.Serializable;

public class Item implements Serializable {
    public Long getItemid() {
        return itemid;
    }

    public void setItemid(Long itemid) {
        this.itemid = itemid;
    }

    private Long itemid;

    public String getItemname() {
        return itemname;
    }

    public void setItemname(String itemname) {
        this.itemname = itemname;
    }

    private String itemname;

    public Integer getPrice() {
        return price;
    }

    public void setPrice(Integer price) {
        this.price = price;
    }

    private Integer price;

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public String getPictureurl() {
        return pictureurl;
    }

    public void setPictureurl(String pictureurl) {
        this.pictureurl = pictureurl;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    private String description;
    private String pictureurl;

    public String getEmail() {
        return email;
    }
    @Override
    public String toString() {
        return "Item{" +
                "itemid=" + itemid +
                ", itemname='" + itemname + '\'' +
                ", price=" + price +
                ", description='" + description + '\'' +
                ", pictureurl='" + pictureurl + '\'' +
                ", email='" + email + '\'' +
                '}';
    }	
    private String email;
}
```  

* 서버로부터 받은 데이터를 로컬 데이터베이스(SQLite3)에 저장하기 위한 Helper클래스 생성 - ItemDB.java  
```java

```