# Mobile을 위한 Server 구축  
## 1. 개발 환경
* 데이터 베이스 : MySQL  
* 프로그래밍 언어 : Java  
* 프레임워크 : Spring Boot  
* IDE : STS  
* 버전 관리 : git hub  

## 2. 데이터 베이스 작업  
* 데이터베이스에 접속해서 이번 프로젝트에 사용할 데이터베이스를 생성  
create database choc;

## 3. Spring Boot Project 생성  
* build : gradle  
* 의존성 : spring dev tools, lombok, spring data jpa, mysql, spring web, thymeleaf  

## 4. 기본 설정  
### 1) application.properties에 작성  
```ini
# 서버 실행 포트 정보
server.port = 80

# 데이터베이스 접속 정보
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:3306/choc?useUnicode=yes&characterEncoding=UTF-8&serverTimezon=UTC
spring.datasource.username=root
spring.datasource.password=1234

# 데이터베이스 사용 옵션 정보
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
spring.jpa.properties.hibernate.show_sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.ddl-auto=update
logging.level.org.hibernate.type.descriptor.sql=trace

#Live Reload
spring.devtools.livereload.enabled=true
```  

### 2) 외부 라이브러리의 의존성을 설정 - BCrypt(복호화가 되지 않은 암호화를 위한 라이브러리 - spring security를 사용하는 경우에는 불필요)
* build.gradle 파일의 dependecies파일에 작성  
// https://mvnrepository.com/artifact/org.mindrot/jbcrypt
implementation group: 'org.mindrot', name: 'jbcrypt', version: '0.4'

* 프로젝트 rebuild  

### 3) 데이터베이스 관련 기본 작업
* main 함수를 가진 클래스에 데이터베이스의 변경내용을 감시할 수 있도록 어노테이션을 설정  
@EnableJpaAuditing
```java
// 자바에서는 @가 붙은 단어를 Annotaion이라고 하고, Python에서는 Decorator라고 합니다.
// 자주 사용하는 코드를 하나의 클래스로 만든 후 이 클래스의 수행 코드를 예약어 형태로 만든 것입니다.
// 이런 코드를 Annotation을 이용해서 만들 수도 있고, AOP를 이용해서 설정하는 것도 가능합니다.
@EnableJpaAuditing
@SpringBootApplication
public class MobileServerApplication {

	public static void main(String[] args) {
		SpringApplication.run(MobileServerApplication.class, args);
	}

}
```  

* Entity들에서 자주 사용하는 속성(생성 날짜, 수정 날짜)들을 위한 Entity를 생성 : model.BaseEntity  
```java
// 테이블로 생성하지 말고 매핑 정보만 사용하겠다라는 의미
@MappedSuperclass
// Entity의 변경사항이 발생했을 때 작업을 수행
@EntityListeners(value= {AuditingEntityListener.class})
// Lombok 라이브러리에서 속성의 getter 메서드를 만들어주는 어노테이션
@Getter
public class BaseEntity {
	// 생성날짜를 이용
	@CreatedDate
	// 테이블에 만들어 질 떄는 regdate라는 컬럼으로 생성되고 수정은 할 수 없음
	@Column(name="regdate", updatable=false)
	private LocalDateTime regDate;

	// 마지막 수정 날짜를 이용
	@LastModifiedDate
	// 테이블에 만들어질 때는 moddate라는 컬럼으로 생성
	@Column(name="moddate")
	private LocalDateTime modDate;
}
```  

## 5. Entity 작업  
* 2개의 테이블을 생성  
하나의 테이블은 회원 정보이고 다른 하나의 테이블은 아이템 정보  
회원은 여러 개의 아이템을 등록할 수 있고 하나의 아이템은 하나의 회원만 등록이 가능  

* Entity를 만들고 application.properties파일에 spring.jpa.properties.hibernate.ddl-auto=update 옵션을 설정하면 테이블이 없으면 테이블이 자동으로 만들어지지만 실제 업무에서는 이 방식을 사용하지 않는데, 컬럼의 순서가 임의로 생성되고, 제약족건의 이름도 임의로 생성됩니다. 애플리케이션 프로그램이 DDL이나 DCL작업을 수행하는 것을 권장하지 않기 째문입니다.  

### 1) 데이터베이스에 접속해서 테이블을 생성하는 구문을 수행  
* sql 실행
```sql
create table tbl_member(
    email varchar(255) not null,
    password varchar(255) not null,
    name varchar(255),
    imageurl varchar(255),
    regdate datetime(6),
    moddate datetime(6),
    lastlogindate datetime(6),
    primary key(email)
)engine=InnoDB DEFAULT CHARSET=utf8;

create table item(
	itemid INTEGER primary key auto_increment,
	itemname varchar(100),
	price Integer,
	description varchar(200),
	pictureurl varchar(255)
    member_email varchar(255)
)engine=InnoDB DEFAULT CHARSET=utf8;
```  

### 2) tbl_member테이블과 연결할 Entity 생성model/Member.java 작성
```java
// 데이터벱이스의 테이블과 연결된 Entity로 설정
@Entity
// 연결할 테이블 이름 설정
@Table(name="tbl_member")
// Builder패턴으로 인스턴스를 생성하도록 해주는 어노테이션
@Builder
// 모든 속성을 매개변수로 하는 생성자를 생성
@AllArgsConstructor
// 매개변수가 없는 DefaultConstructor 생성
@NoArgsConstructor
@Getter
// 모든 속성의 toString을 호출한 결과를가지고 toString을 생성
@ToString
public class Member extends BaseEntity{
	@Id
	private String email;
	private String password;
	private String name;
	private String imageurl;
	private LocalDateTime lastlogindate;
}
```  

### 3) Item테이블과 연결할 Entity 생성 - model/Item.java  
```java
package com.choc.model;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.ManyToOne;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;

@Entity
@Builder
@AllArgsConstructor
@NoArgsConstructor
@Data
@ToString(exclude="member") // member.toString은 제외
public class Item {
	@Id
	// 기본키 값을 auto_increment나 sequence를 이용해서 자동 생성
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Long itemid;
	@Column(length=100, nullable = false)
	private String itemname;
	@Column
	private Integer price;
	@Column(length = 200)
	private String description;
	@Column(length = 255)
	private String pictureurl;
	
	// 사용을 할 때 데이터를 가져오겠다는 옵션
	@ManyToOne(fetch=FetchType.LAZY)
	private Member member;
}
```  

## 6. Repository 작업  
### +)  Jpa에서 데이터베이스를 사용하는 방법  
#### 1. JpaRepository가 제공하는 기본 메서드를 사용하는 방법  
* Entity를 이용한 데이터 삽입, 데이터 수정(Id를 기준으로 수정), 데이터 삭제(Id를 기준으로 삭제)  
* id를 이용한 삭제 제공  
* 테이블의 전체 데이터를 조회, Pageable을 이용한 조회, 기본키를 이용한 조회  
#### 2. 메서드 이름을 이용하는 방법  
* 기능 + Entity이름(생략가능) + By + 컬럼이름으로 메서드를 생성  
* 조회와 삭제 가능
* 연산자(크다, 작다, 작거나 같다, 크거나 같다, 사이, like 등) 사용 가능  
* name을 이용한 데이터 조회 : findByName(String name)
* name을 이용한 삭제 : deleteByName(String name)  
#### 3. JPQL을 이용하는 방법 - join이 필요할 때 주로 이용  
@Query("쿼리")  
매서드이름(@Param("파라미터이름") 자료형 매개변수 이름 ... )  
#### 4. QueryDsl을 이용해서 JPQL을 동적으로 생성하는 방법  
* 값을 변경하는 쿼리는 정적으로 생성이 가능  
* 테이블 이름이나 컬럼이름을 변경해야 하는 경우는 **QueryDsl**을 이용해야 합니다.  
* 입력받은 값을 이용해서 title에서 조회 
	~> title = 입력받은 값, 이런 경우는 JPQL로 처리가 가능  
* 값을 입력받아서 어떤 경우에는 title에서 조회하고 다른 경우에는 content에서 조회해야 하는 경우  
	~> 이런 경우에는 JPQL을 동적으로 생성해야 합니다. 이 경우 "QueryDsl" 사용  

### 1) Member Entity작업을 위한 Repository 인터페이스 생성 - persistence.MemberRepository  
```java
// JpaRepository를 상속 받을 때는 Entity이름과 Id로 설정한 속성의 자료형이 필요
public interface MemberRepository extends JpaRepository<Member, String> {
	// 회원가입
	// 로그인
	// 회원 정보 가져오기
	// 회원 정보 수정
	// 회원 탈퇴
}
```  

### 2) test디렉터리에 Repository를 테스트할 수 있는 클래스를 만들고 테스트 - Repositorytest.java  
```java
package com.choc;

import java.util.Optional;

import org.junit.jupiter.api.Test;
import org.mindrot.jbcrypt.BCrypt;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import com.choc.model.Member;
import com.choc.persistence.MemberRepository;

@SpringBootTest
public class RepositoryTest {
	@Autowired
	private MemberRepository m;
	
	// Member에 데이터 삽입
	//@Test
	public void testRegisterMember() {
		/*
		Member member = Member.builder().email("dntksemfdj473@gmail.com")
				.password("159753").name("촉촉한초코칩").imageurl("chocochip.png").build();
		m.save(member);
		*/
		
		// BCrypt 사용해보기
		/*
		String password = BCrypt.hashpw("159753", BCrypt.gensalt()); 
		// 같은 데이터를 가지고 암호화해도 매번 다른 값이 나옴
		System.out.println(password);
		System.out.println(BCrypt.checkpw("159753", password)); // 평문이 같으면 true
		*/
		// password에 String 형태로 hash된 값이 들어간 것이 확인됨
		String password = BCrypt.hashpw("159753", BCrypt.gensalt());
		Member member = Member.builder().email("dntksemfdj473@gmail.com")
				.password(password).name("촉촉한초코칩").imageurl("chocochip.png").build();
		m.save(member);
	}
	
	// 회원 정보 가져오기 - 수정이나 로그인에서 사용  
	//@Test
	public void testGetMember() {
		Optional<Member> optional = m.findById("dntksemfdj473@gmail.com");
		if(optional.isPresent()) {
			Member member = optional.get();
			System.out.println(member); // 로그인은 데이터를 가져와서 비교하면 됨!
		}else {
			System.out.println("존재하지 않는 데이터입니다.");
		}
	}
	
	// 데이터 수정
	//@Test
	public void testUpdateMember() {
		String password = BCrypt.hashpw("111111", BCrypt.gensalt());
		Member member = Member.builder().email("dntksemfdj473@gmail.com")
				.password(password).name("칙촉").imageurl("user.png").build();
		
		m.save(member);
	}
	
	// 데이터 삭제
	@Test
	public void testDeleteMember() {
		// 2가지 방법 존재
		Member member = Member.builder().email("dntksemfdj473@gmail.com").build();
		m.delete(member);
		

		//m.deleteById("dntksemfdj473@gmail.com");
	}
}
```  

### 3) Item테이블을 위한Repository 인터페이스 생성 - persistence.ItemRepository  
```java

```
